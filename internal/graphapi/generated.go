// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"go.infratographer.com/load-balancer-api/internal/ent/generated"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/pool"
	"go.infratographer.com/x/entx"
	"go.infratographer.com/x/gidx"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Entity() EntityResolver
	LoadBalancer() LoadBalancerResolver
	LoadBalancerPool() LoadBalancerPoolResolver
	Location() LocationResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Tenant() TenantResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Entity struct {
		FindLoadBalancerAnnotationByID func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerByID           func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerOriginByID     func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerPoolByID       func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerPortByID       func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerProviderByID   func(childComplexity int, id gidx.PrefixedID) int
		FindLoadBalancerStatusByID     func(childComplexity int, id gidx.PrefixedID) int
		FindLocationByID               func(childComplexity int, id gidx.PrefixedID) int
		FindTenantByID                 func(childComplexity int, id gidx.PrefixedID) int
	}

	LoadBalancer struct {
		Annotations func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerAnnotationOrder, where *generated.LoadBalancerAnnotationWhereInput) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Location    func(childComplexity int) int
		LocationID  func(childComplexity int) int
		Name        func(childComplexity int) int
		Provider    func(childComplexity int) int
		Statuses    func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerStatusOrder, where *generated.LoadBalancerStatusWhereInput) int
		Tenant      func(childComplexity int) int
		TenantID    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	LoadBalancerAnnotation struct {
		CreatedAt      func(childComplexity int) int
		Data           func(childComplexity int) int
		ID             func(childComplexity int) int
		LoadBalancer   func(childComplexity int) int
		LoadBalancerID func(childComplexity int) int
		Namespace      func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	LoadBalancerAnnotationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerAnnotationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerOrigin struct {
		Active     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Pool       func(childComplexity int) int
		PoolID     func(childComplexity int) int
		PortNumber func(childComplexity int) int
		Target     func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	LoadBalancerOriginConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerOriginEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerPool struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Origins   func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOriginOrder, where *generated.LoadBalancerOriginWhereInput) int
		Ports     func(childComplexity int) int
		Protocol  func(childComplexity int) int
		Tenant    func(childComplexity int) int
		TenantID  func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	LoadBalancerPoolConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerPoolEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerPort struct {
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LoadBalancer   func(childComplexity int) int
		LoadBalancerID func(childComplexity int) int
		Name           func(childComplexity int) int
		Number         func(childComplexity int) int
		Pools          func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	LoadBalancerPortConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerPortEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerProvider struct {
		CreatedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		LoadBalancers func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOrder, where *generated.LoadBalancerWhereInput) int
		Name          func(childComplexity int) int
		TenantID      func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	LoadBalancerProviderConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerProviderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoadBalancerStatus struct {
		CreatedAt      func(childComplexity int) int
		Data           func(childComplexity int) int
		ID             func(childComplexity int) int
		LoadBalancer   func(childComplexity int) int
		LoadBalancerID func(childComplexity int) int
		Namespace      func(childComplexity int) int
		Source         func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	LoadBalancerStatusConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LoadBalancerStatusEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Location struct {
		ID            func(childComplexity int) int
		LoadBalancers func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOrder, where *generated.LoadBalancerWhereInput) int
	}

	Mutation struct {
		CreateLoadBalancer         func(childComplexity int, input generated.CreateLoadBalancerInput) int
		CreateLoadBalancerProvider func(childComplexity int, input generated.CreateLoadBalancerProviderInput) int
		UpdateLoadBalancer         func(childComplexity int, id gidx.PrefixedID, input generated.UpdateLoadBalancerInput) int
		UpdateLoadBalancerProvider func(childComplexity int, id gidx.PrefixedID, input generated.UpdateLoadBalancerProviderInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		LoadBalancerPools     func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerPoolOrder, where *generated.LoadBalancerPoolWhereInput) int
		LoadBalancerProviders func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerProviderOrder, where *generated.LoadBalancerProviderWhereInput) int
		__resolve__service    func(childComplexity int) int
		__resolve_entities    func(childComplexity int, representations []map[string]interface{}) int
	}

	Tenant struct {
		ID                func(childComplexity int) int
		LoadBalancerPools func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerPoolOrder, where *generated.LoadBalancerPoolWhereInput) int
		LoadBalancers     func(childComplexity int, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOrder, where *generated.LoadBalancerWhereInput) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type EntityResolver interface {
	FindLoadBalancerByID(ctx context.Context, id gidx.PrefixedID) (*generated.LoadBalancer, error)
	FindLoadBalancerAnnotationByID(ctx context.Context, id gidx.PrefixedID) (*generated.LoadBalancerAnnotation, error)
	FindLoadBalancerOriginByID(ctx context.Context, id gidx.PrefixedID) (*generated.Origin, error)
	FindLoadBalancerPoolByID(ctx context.Context, id gidx.PrefixedID) (*generated.Pool, error)
	FindLoadBalancerPortByID(ctx context.Context, id gidx.PrefixedID) (*generated.Port, error)
	FindLoadBalancerProviderByID(ctx context.Context, id gidx.PrefixedID) (*generated.Provider, error)
	FindLoadBalancerStatusByID(ctx context.Context, id gidx.PrefixedID) (*generated.LoadBalancerStatus, error)
	FindLocationByID(ctx context.Context, id gidx.PrefixedID) (*Location, error)
	FindTenantByID(ctx context.Context, id gidx.PrefixedID) (*Tenant, error)
}
type LoadBalancerResolver interface {
	Location(ctx context.Context, obj *generated.LoadBalancer) (*Location, error)
	Tenant(ctx context.Context, obj *generated.LoadBalancer) (*Tenant, error)
}
type LoadBalancerPoolResolver interface {
	Tenant(ctx context.Context, obj *generated.Pool) (*Tenant, error)
}
type LocationResolver interface {
	LoadBalancers(ctx context.Context, obj *Location, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOrder, where *generated.LoadBalancerWhereInput) (*generated.LoadBalancerConnection, error)
}
type MutationResolver interface {
	CreateLoadBalancer(ctx context.Context, input generated.CreateLoadBalancerInput) (*generated.LoadBalancer, error)
	UpdateLoadBalancer(ctx context.Context, id gidx.PrefixedID, input generated.UpdateLoadBalancerInput) (*generated.LoadBalancer, error)
	CreateLoadBalancerProvider(ctx context.Context, input generated.CreateLoadBalancerProviderInput) (*generated.Provider, error)
	UpdateLoadBalancerProvider(ctx context.Context, id gidx.PrefixedID, input generated.UpdateLoadBalancerProviderInput) (*generated.Provider, error)
}
type QueryResolver interface {
	LoadBalancerPools(ctx context.Context, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerPoolOrder, where *generated.LoadBalancerPoolWhereInput) (*generated.LoadBalancerPoolConnection, error)
	LoadBalancerProviders(ctx context.Context, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerProviderOrder, where *generated.LoadBalancerProviderWhereInput) (*generated.LoadBalancerProviderConnection, error)
}
type TenantResolver interface {
	LoadBalancers(ctx context.Context, obj *Tenant, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerOrder, where *generated.LoadBalancerWhereInput) (*generated.LoadBalancerConnection, error)
	LoadBalancerPools(ctx context.Context, obj *Tenant, after *entgql.Cursor[gidx.PrefixedID], first *int, before *entgql.Cursor[gidx.PrefixedID], last *int, orderBy *generated.LoadBalancerPoolOrder, where *generated.LoadBalancerPoolWhereInput) (*generated.LoadBalancerPoolConnection, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Entity.findLoadBalancerAnnotationByID":
		if e.complexity.Entity.FindLoadBalancerAnnotationByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerAnnotationByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerAnnotationByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerByID":
		if e.complexity.Entity.FindLoadBalancerByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerOriginByID":
		if e.complexity.Entity.FindLoadBalancerOriginByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerOriginByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerOriginByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerPoolByID":
		if e.complexity.Entity.FindLoadBalancerPoolByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerPoolByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerPoolByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerPortByID":
		if e.complexity.Entity.FindLoadBalancerPortByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerPortByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerPortByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerProviderByID":
		if e.complexity.Entity.FindLoadBalancerProviderByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerProviderByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerProviderByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLoadBalancerStatusByID":
		if e.complexity.Entity.FindLoadBalancerStatusByID == nil {
			break
		}

		args, err := ec.field_Entity_findLoadBalancerStatusByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLoadBalancerStatusByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findLocationByID":
		if e.complexity.Entity.FindLocationByID == nil {
			break
		}

		args, err := ec.field_Entity_findLocationByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLocationByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "Entity.findTenantByID":
		if e.complexity.Entity.FindTenantByID == nil {
			break
		}

		args, err := ec.field_Entity_findTenantByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindTenantByID(childComplexity, args["id"].(gidx.PrefixedID)), true

	case "LoadBalancer.annotations":
		if e.complexity.LoadBalancer.Annotations == nil {
			break
		}

		args, err := ec.field_LoadBalancer_annotations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LoadBalancer.Annotations(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerAnnotationOrder), args["where"].(*generated.LoadBalancerAnnotationWhereInput)), true

	case "LoadBalancer.createdAt":
		if e.complexity.LoadBalancer.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancer.CreatedAt(childComplexity), true

	case "LoadBalancer.id":
		if e.complexity.LoadBalancer.ID == nil {
			break
		}

		return e.complexity.LoadBalancer.ID(childComplexity), true

	case "LoadBalancer.location":
		if e.complexity.LoadBalancer.Location == nil {
			break
		}

		return e.complexity.LoadBalancer.Location(childComplexity), true

	case "LoadBalancer.locationID":
		if e.complexity.LoadBalancer.LocationID == nil {
			break
		}

		return e.complexity.LoadBalancer.LocationID(childComplexity), true

	case "LoadBalancer.name":
		if e.complexity.LoadBalancer.Name == nil {
			break
		}

		return e.complexity.LoadBalancer.Name(childComplexity), true

	case "LoadBalancer.loadBalancerProvider":
		if e.complexity.LoadBalancer.Provider == nil {
			break
		}

		return e.complexity.LoadBalancer.Provider(childComplexity), true

	case "LoadBalancer.statuses":
		if e.complexity.LoadBalancer.Statuses == nil {
			break
		}

		args, err := ec.field_LoadBalancer_statuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LoadBalancer.Statuses(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerStatusOrder), args["where"].(*generated.LoadBalancerStatusWhereInput)), true

	case "LoadBalancer.tenant":
		if e.complexity.LoadBalancer.Tenant == nil {
			break
		}

		return e.complexity.LoadBalancer.Tenant(childComplexity), true

	case "LoadBalancer.tenantID":
		if e.complexity.LoadBalancer.TenantID == nil {
			break
		}

		return e.complexity.LoadBalancer.TenantID(childComplexity), true

	case "LoadBalancer.updatedAt":
		if e.complexity.LoadBalancer.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancer.UpdatedAt(childComplexity), true

	case "LoadBalancerAnnotation.createdAt":
		if e.complexity.LoadBalancerAnnotation.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.CreatedAt(childComplexity), true

	case "LoadBalancerAnnotation.data":
		if e.complexity.LoadBalancerAnnotation.Data == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.Data(childComplexity), true

	case "LoadBalancerAnnotation.id":
		if e.complexity.LoadBalancerAnnotation.ID == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.ID(childComplexity), true

	case "LoadBalancerAnnotation.loadBalancer":
		if e.complexity.LoadBalancerAnnotation.LoadBalancer == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.LoadBalancer(childComplexity), true

	case "LoadBalancerAnnotation.loadBalancerID":
		if e.complexity.LoadBalancerAnnotation.LoadBalancerID == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.LoadBalancerID(childComplexity), true

	case "LoadBalancerAnnotation.namespace":
		if e.complexity.LoadBalancerAnnotation.Namespace == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.Namespace(childComplexity), true

	case "LoadBalancerAnnotation.updatedAt":
		if e.complexity.LoadBalancerAnnotation.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotation.UpdatedAt(childComplexity), true

	case "LoadBalancerAnnotationConnection.edges":
		if e.complexity.LoadBalancerAnnotationConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotationConnection.Edges(childComplexity), true

	case "LoadBalancerAnnotationConnection.pageInfo":
		if e.complexity.LoadBalancerAnnotationConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotationConnection.PageInfo(childComplexity), true

	case "LoadBalancerAnnotationConnection.totalCount":
		if e.complexity.LoadBalancerAnnotationConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotationConnection.TotalCount(childComplexity), true

	case "LoadBalancerAnnotationEdge.cursor":
		if e.complexity.LoadBalancerAnnotationEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotationEdge.Cursor(childComplexity), true

	case "LoadBalancerAnnotationEdge.node":
		if e.complexity.LoadBalancerAnnotationEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerAnnotationEdge.Node(childComplexity), true

	case "LoadBalancerConnection.edges":
		if e.complexity.LoadBalancerConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerConnection.Edges(childComplexity), true

	case "LoadBalancerConnection.pageInfo":
		if e.complexity.LoadBalancerConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerConnection.PageInfo(childComplexity), true

	case "LoadBalancerConnection.totalCount":
		if e.complexity.LoadBalancerConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerConnection.TotalCount(childComplexity), true

	case "LoadBalancerEdge.cursor":
		if e.complexity.LoadBalancerEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerEdge.Cursor(childComplexity), true

	case "LoadBalancerEdge.node":
		if e.complexity.LoadBalancerEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerEdge.Node(childComplexity), true

	case "LoadBalancerOrigin.active":
		if e.complexity.LoadBalancerOrigin.Active == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.Active(childComplexity), true

	case "LoadBalancerOrigin.createdAt":
		if e.complexity.LoadBalancerOrigin.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.CreatedAt(childComplexity), true

	case "LoadBalancerOrigin.id":
		if e.complexity.LoadBalancerOrigin.ID == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.ID(childComplexity), true

	case "LoadBalancerOrigin.name":
		if e.complexity.LoadBalancerOrigin.Name == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.Name(childComplexity), true

	case "LoadBalancerOrigin.pool":
		if e.complexity.LoadBalancerOrigin.Pool == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.Pool(childComplexity), true

	case "LoadBalancerOrigin.poolID":
		if e.complexity.LoadBalancerOrigin.PoolID == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.PoolID(childComplexity), true

	case "LoadBalancerOrigin.portNumber":
		if e.complexity.LoadBalancerOrigin.PortNumber == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.PortNumber(childComplexity), true

	case "LoadBalancerOrigin.target":
		if e.complexity.LoadBalancerOrigin.Target == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.Target(childComplexity), true

	case "LoadBalancerOrigin.updatedAt":
		if e.complexity.LoadBalancerOrigin.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerOrigin.UpdatedAt(childComplexity), true

	case "LoadBalancerOriginConnection.edges":
		if e.complexity.LoadBalancerOriginConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerOriginConnection.Edges(childComplexity), true

	case "LoadBalancerOriginConnection.pageInfo":
		if e.complexity.LoadBalancerOriginConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerOriginConnection.PageInfo(childComplexity), true

	case "LoadBalancerOriginConnection.totalCount":
		if e.complexity.LoadBalancerOriginConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerOriginConnection.TotalCount(childComplexity), true

	case "LoadBalancerOriginEdge.cursor":
		if e.complexity.LoadBalancerOriginEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerOriginEdge.Cursor(childComplexity), true

	case "LoadBalancerOriginEdge.node":
		if e.complexity.LoadBalancerOriginEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerOriginEdge.Node(childComplexity), true

	case "LoadBalancerPool.createdAt":
		if e.complexity.LoadBalancerPool.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerPool.CreatedAt(childComplexity), true

	case "LoadBalancerPool.id":
		if e.complexity.LoadBalancerPool.ID == nil {
			break
		}

		return e.complexity.LoadBalancerPool.ID(childComplexity), true

	case "LoadBalancerPool.name":
		if e.complexity.LoadBalancerPool.Name == nil {
			break
		}

		return e.complexity.LoadBalancerPool.Name(childComplexity), true

	case "LoadBalancerPool.origins":
		if e.complexity.LoadBalancerPool.Origins == nil {
			break
		}

		args, err := ec.field_LoadBalancerPool_origins_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LoadBalancerPool.Origins(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerOriginOrder), args["where"].(*generated.LoadBalancerOriginWhereInput)), true

	case "LoadBalancerPool.ports":
		if e.complexity.LoadBalancerPool.Ports == nil {
			break
		}

		return e.complexity.LoadBalancerPool.Ports(childComplexity), true

	case "LoadBalancerPool.protocol":
		if e.complexity.LoadBalancerPool.Protocol == nil {
			break
		}

		return e.complexity.LoadBalancerPool.Protocol(childComplexity), true

	case "LoadBalancerPool.tenant":
		if e.complexity.LoadBalancerPool.Tenant == nil {
			break
		}

		return e.complexity.LoadBalancerPool.Tenant(childComplexity), true

	case "LoadBalancerPool.tenantID":
		if e.complexity.LoadBalancerPool.TenantID == nil {
			break
		}

		return e.complexity.LoadBalancerPool.TenantID(childComplexity), true

	case "LoadBalancerPool.updatedAt":
		if e.complexity.LoadBalancerPool.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerPool.UpdatedAt(childComplexity), true

	case "LoadBalancerPoolConnection.edges":
		if e.complexity.LoadBalancerPoolConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerPoolConnection.Edges(childComplexity), true

	case "LoadBalancerPoolConnection.pageInfo":
		if e.complexity.LoadBalancerPoolConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerPoolConnection.PageInfo(childComplexity), true

	case "LoadBalancerPoolConnection.totalCount":
		if e.complexity.LoadBalancerPoolConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerPoolConnection.TotalCount(childComplexity), true

	case "LoadBalancerPoolEdge.cursor":
		if e.complexity.LoadBalancerPoolEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerPoolEdge.Cursor(childComplexity), true

	case "LoadBalancerPoolEdge.node":
		if e.complexity.LoadBalancerPoolEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerPoolEdge.Node(childComplexity), true

	case "LoadBalancerPort.createdAt":
		if e.complexity.LoadBalancerPort.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerPort.CreatedAt(childComplexity), true

	case "LoadBalancerPort.id":
		if e.complexity.LoadBalancerPort.ID == nil {
			break
		}

		return e.complexity.LoadBalancerPort.ID(childComplexity), true

	case "LoadBalancerPort.loadBalancer":
		if e.complexity.LoadBalancerPort.LoadBalancer == nil {
			break
		}

		return e.complexity.LoadBalancerPort.LoadBalancer(childComplexity), true

	case "LoadBalancerPort.loadBalancerID":
		if e.complexity.LoadBalancerPort.LoadBalancerID == nil {
			break
		}

		return e.complexity.LoadBalancerPort.LoadBalancerID(childComplexity), true

	case "LoadBalancerPort.name":
		if e.complexity.LoadBalancerPort.Name == nil {
			break
		}

		return e.complexity.LoadBalancerPort.Name(childComplexity), true

	case "LoadBalancerPort.number":
		if e.complexity.LoadBalancerPort.Number == nil {
			break
		}

		return e.complexity.LoadBalancerPort.Number(childComplexity), true

	case "LoadBalancerPort.pools":
		if e.complexity.LoadBalancerPort.Pools == nil {
			break
		}

		return e.complexity.LoadBalancerPort.Pools(childComplexity), true

	case "LoadBalancerPort.updatedAt":
		if e.complexity.LoadBalancerPort.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerPort.UpdatedAt(childComplexity), true

	case "LoadBalancerPortConnection.edges":
		if e.complexity.LoadBalancerPortConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerPortConnection.Edges(childComplexity), true

	case "LoadBalancerPortConnection.pageInfo":
		if e.complexity.LoadBalancerPortConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerPortConnection.PageInfo(childComplexity), true

	case "LoadBalancerPortConnection.totalCount":
		if e.complexity.LoadBalancerPortConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerPortConnection.TotalCount(childComplexity), true

	case "LoadBalancerPortEdge.cursor":
		if e.complexity.LoadBalancerPortEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerPortEdge.Cursor(childComplexity), true

	case "LoadBalancerPortEdge.node":
		if e.complexity.LoadBalancerPortEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerPortEdge.Node(childComplexity), true

	case "LoadBalancerProvider.createdAt":
		if e.complexity.LoadBalancerProvider.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerProvider.CreatedAt(childComplexity), true

	case "LoadBalancerProvider.id":
		if e.complexity.LoadBalancerProvider.ID == nil {
			break
		}

		return e.complexity.LoadBalancerProvider.ID(childComplexity), true

	case "LoadBalancerProvider.loadBalancers":
		if e.complexity.LoadBalancerProvider.LoadBalancers == nil {
			break
		}

		args, err := ec.field_LoadBalancerProvider_loadBalancers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LoadBalancerProvider.LoadBalancers(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerOrder), args["where"].(*generated.LoadBalancerWhereInput)), true

	case "LoadBalancerProvider.name":
		if e.complexity.LoadBalancerProvider.Name == nil {
			break
		}

		return e.complexity.LoadBalancerProvider.Name(childComplexity), true

	case "LoadBalancerProvider.tenantID":
		if e.complexity.LoadBalancerProvider.TenantID == nil {
			break
		}

		return e.complexity.LoadBalancerProvider.TenantID(childComplexity), true

	case "LoadBalancerProvider.updatedAt":
		if e.complexity.LoadBalancerProvider.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerProvider.UpdatedAt(childComplexity), true

	case "LoadBalancerProviderConnection.edges":
		if e.complexity.LoadBalancerProviderConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerProviderConnection.Edges(childComplexity), true

	case "LoadBalancerProviderConnection.pageInfo":
		if e.complexity.LoadBalancerProviderConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerProviderConnection.PageInfo(childComplexity), true

	case "LoadBalancerProviderConnection.totalCount":
		if e.complexity.LoadBalancerProviderConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerProviderConnection.TotalCount(childComplexity), true

	case "LoadBalancerProviderEdge.cursor":
		if e.complexity.LoadBalancerProviderEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerProviderEdge.Cursor(childComplexity), true

	case "LoadBalancerProviderEdge.node":
		if e.complexity.LoadBalancerProviderEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerProviderEdge.Node(childComplexity), true

	case "LoadBalancerStatus.createdAt":
		if e.complexity.LoadBalancerStatus.CreatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.CreatedAt(childComplexity), true

	case "LoadBalancerStatus.data":
		if e.complexity.LoadBalancerStatus.Data == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.Data(childComplexity), true

	case "LoadBalancerStatus.id":
		if e.complexity.LoadBalancerStatus.ID == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.ID(childComplexity), true

	case "LoadBalancerStatus.loadBalancer":
		if e.complexity.LoadBalancerStatus.LoadBalancer == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.LoadBalancer(childComplexity), true

	case "LoadBalancerStatus.loadBalancerID":
		if e.complexity.LoadBalancerStatus.LoadBalancerID == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.LoadBalancerID(childComplexity), true

	case "LoadBalancerStatus.namespace":
		if e.complexity.LoadBalancerStatus.Namespace == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.Namespace(childComplexity), true

	case "LoadBalancerStatus.source":
		if e.complexity.LoadBalancerStatus.Source == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.Source(childComplexity), true

	case "LoadBalancerStatus.updatedAt":
		if e.complexity.LoadBalancerStatus.UpdatedAt == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.UpdatedAt(childComplexity), true

	case "LoadBalancerStatusConnection.edges":
		if e.complexity.LoadBalancerStatusConnection.Edges == nil {
			break
		}

		return e.complexity.LoadBalancerStatusConnection.Edges(childComplexity), true

	case "LoadBalancerStatusConnection.pageInfo":
		if e.complexity.LoadBalancerStatusConnection.PageInfo == nil {
			break
		}

		return e.complexity.LoadBalancerStatusConnection.PageInfo(childComplexity), true

	case "LoadBalancerStatusConnection.totalCount":
		if e.complexity.LoadBalancerStatusConnection.TotalCount == nil {
			break
		}

		return e.complexity.LoadBalancerStatusConnection.TotalCount(childComplexity), true

	case "LoadBalancerStatusEdge.cursor":
		if e.complexity.LoadBalancerStatusEdge.Cursor == nil {
			break
		}

		return e.complexity.LoadBalancerStatusEdge.Cursor(childComplexity), true

	case "LoadBalancerStatusEdge.node":
		if e.complexity.LoadBalancerStatusEdge.Node == nil {
			break
		}

		return e.complexity.LoadBalancerStatusEdge.Node(childComplexity), true

	case "Location.id":
		if e.complexity.Location.ID == nil {
			break
		}

		return e.complexity.Location.ID(childComplexity), true

	case "Location.loadBalancers":
		if e.complexity.Location.LoadBalancers == nil {
			break
		}

		args, err := ec.field_Location_loadBalancers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Location.LoadBalancers(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerOrder), args["where"].(*generated.LoadBalancerWhereInput)), true

	case "Mutation.createLoadBalancer":
		if e.complexity.Mutation.CreateLoadBalancer == nil {
			break
		}

		args, err := ec.field_Mutation_createLoadBalancer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLoadBalancer(childComplexity, args["input"].(generated.CreateLoadBalancerInput)), true

	case "Mutation.createLoadBalancerProvider":
		if e.complexity.Mutation.CreateLoadBalancerProvider == nil {
			break
		}

		args, err := ec.field_Mutation_createLoadBalancerProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLoadBalancerProvider(childComplexity, args["input"].(generated.CreateLoadBalancerProviderInput)), true

	case "Mutation.updateLoadBalancer":
		if e.complexity.Mutation.UpdateLoadBalancer == nil {
			break
		}

		args, err := ec.field_Mutation_updateLoadBalancer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLoadBalancer(childComplexity, args["id"].(gidx.PrefixedID), args["input"].(generated.UpdateLoadBalancerInput)), true

	case "Mutation.updateLoadBalancerProvider":
		if e.complexity.Mutation.UpdateLoadBalancerProvider == nil {
			break
		}

		args, err := ec.field_Mutation_updateLoadBalancerProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLoadBalancerProvider(childComplexity, args["id"].(gidx.PrefixedID), args["input"].(generated.UpdateLoadBalancerProviderInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.loadBalancerPools":
		if e.complexity.Query.LoadBalancerPools == nil {
			break
		}

		args, err := ec.field_Query_loadBalancerPools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LoadBalancerPools(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerPoolOrder), args["where"].(*generated.LoadBalancerPoolWhereInput)), true

	case "Query.loadBalancerProviders":
		if e.complexity.Query.LoadBalancerProviders == nil {
			break
		}

		args, err := ec.field_Query_loadBalancerProviders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LoadBalancerProviders(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerProviderOrder), args["where"].(*generated.LoadBalancerProviderWhereInput)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Query._entities":
		if e.complexity.Query.__resolve_entities == nil {
			break
		}

		args, err := ec.field_Query__entities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.__resolve_entities(childComplexity, args["representations"].([]map[string]interface{})), true

	case "Tenant.id":
		if e.complexity.Tenant.ID == nil {
			break
		}

		return e.complexity.Tenant.ID(childComplexity), true

	case "Tenant.loadBalancerPools":
		if e.complexity.Tenant.LoadBalancerPools == nil {
			break
		}

		args, err := ec.field_Tenant_loadBalancerPools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tenant.LoadBalancerPools(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerPoolOrder), args["where"].(*generated.LoadBalancerPoolWhereInput)), true

	case "Tenant.loadBalancers":
		if e.complexity.Tenant.LoadBalancers == nil {
			break
		}

		args, err := ec.field_Tenant_loadBalancers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tenant.LoadBalancers(childComplexity, args["after"].(*entgql.Cursor[gidx.PrefixedID]), args["first"].(*int), args["before"].(*entgql.Cursor[gidx.PrefixedID]), args["last"].(*int), args["orderBy"].(*generated.LoadBalancerOrder), args["where"].(*generated.LoadBalancerWhereInput)), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateLoadBalancerInput,
		ec.unmarshalInputCreateLoadBalancerOriginInput,
		ec.unmarshalInputCreateLoadBalancerPoolInput,
		ec.unmarshalInputCreateLoadBalancerPortInput,
		ec.unmarshalInputCreateLoadBalancerProviderInput,
		ec.unmarshalInputLoadBalancerAnnotationOrder,
		ec.unmarshalInputLoadBalancerAnnotationWhereInput,
		ec.unmarshalInputLoadBalancerOrder,
		ec.unmarshalInputLoadBalancerOriginOrder,
		ec.unmarshalInputLoadBalancerOriginWhereInput,
		ec.unmarshalInputLoadBalancerPoolOrder,
		ec.unmarshalInputLoadBalancerPoolWhereInput,
		ec.unmarshalInputLoadBalancerPortOrder,
		ec.unmarshalInputLoadBalancerPortWhereInput,
		ec.unmarshalInputLoadBalancerProviderOrder,
		ec.unmarshalInputLoadBalancerProviderWhereInput,
		ec.unmarshalInputLoadBalancerStatusOrder,
		ec.unmarshalInputLoadBalancerStatusWhereInput,
		ec.unmarshalInputLoadBalancerWhereInput,
		ec.unmarshalInputUpdateLoadBalancerInput,
		ec.unmarshalInputUpdateLoadBalancerOriginInput,
		ec.unmarshalInputUpdateLoadBalancerPoolInput,
		ec.unmarshalInputUpdateLoadBalancerPortInput,
		ec.unmarshalInputUpdateLoadBalancerProviderInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateLoadBalancerInput is used for create LoadBalancer object.
Input was generated by ent.
"""
input CreateLoadBalancerInput {
  name: String!
  tenantID: ID!
  locationID: ID!
  annotationIDs: [ID!]
  statusIDs: [ID!]
  providerID: ID!
}
"""
CreateLoadBalancerOriginInput is used for create LoadBalancerOrigin object.
Input was generated by ent.
"""
input CreateLoadBalancerOriginInput {
  name: String!
  target: String!
  portNumber: Int!
  active: Boolean
  poolID: ID!
}
"""
CreateLoadBalancerPoolInput is used for create LoadBalancerPool object.
Input was generated by ent.
"""
input CreateLoadBalancerPoolInput {
  name: String!
  protocol: LoadBalancerPoolProtocol!
  tenantID: ID!
  portIDs: [ID!]
  originIDs: [ID!]
}
"""
CreateLoadBalancerPortInput is used for create LoadBalancerPort object.
Input was generated by ent.
"""
input CreateLoadBalancerPortInput {
  number: Int!
  name: String!
  poolIDs: [ID!]
  loadBalancerID: ID!
}
"""
CreateLoadBalancerProviderInput is used for create LoadBalancerProvider object.
Input was generated by ent.
"""
input CreateLoadBalancerProviderInput {
  name: String!
  tenantID: ID!
  loadBalancerIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""A valid JSON string."""
scalar JSON
type LoadBalancer implements Node & IPv4Addressable @key(fields: "id") {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  tenantID: ID!
  locationID: ID!
  annotations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerAnnotations returned from the connection."""
    orderBy: LoadBalancerAnnotationOrder

    """Filtering options for LoadBalancerAnnotations returned from the connection."""
    where: LoadBalancerAnnotationWhereInput
  ): LoadBalancerAnnotationConnection!
  statuses(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerStatusSlice returned from the connection."""
    orderBy: LoadBalancerStatusOrder

    """Filtering options for LoadBalancerStatusSlice returned from the connection."""
    where: LoadBalancerStatusWhereInput
  ): LoadBalancerStatusConnection!
  loadBalancerProvider: LoadBalancerProvider! @goField(name: "Provider", forceResolver: false)
}
type LoadBalancerAnnotation implements Node @key(fields: "id") {
  id: ID!
  namespace: String!
  data: JSON!
  createdAt: Time!
  updatedAt: Time!
  loadBalancerID: ID!
  loadBalancer: LoadBalancer!
}
"""A connection to a list of items."""
type LoadBalancerAnnotationConnection {
  """A list of edges."""
  edges: [LoadBalancerAnnotationEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerAnnotationEdge {
  """The item at the end of the edge."""
  node: LoadBalancerAnnotation
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerAnnotation connections"""
input LoadBalancerAnnotationOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerAnnotations."""
  field: LoadBalancerAnnotationOrderField!
}
"""Properties by which LoadBalancerAnnotation connections can be ordered."""
enum LoadBalancerAnnotationOrderField {
  NAMESPACE
  CREATED_AT
  UPDATED_AT
}
"""
LoadBalancerAnnotationWhereInput is used for filtering LoadBalancerAnnotation objects.
Input was generated by ent.
"""
input LoadBalancerAnnotationWhereInput {
  not: LoadBalancerAnnotationWhereInput
  and: [LoadBalancerAnnotationWhereInput!]
  or: [LoadBalancerAnnotationWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """namespace field predicates"""
  namespace: String
  namespaceNEQ: String
  namespaceIn: [String!]
  namespaceNotIn: [String!]
  namespaceGT: String
  namespaceGTE: String
  namespaceLT: String
  namespaceLTE: String
  namespaceContains: String
  namespaceHasPrefix: String
  namespaceHasSuffix: String
  namespaceEqualFold: String
  namespaceContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """load_balancer edge predicates"""
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
"""A connection to a list of items."""
type LoadBalancerConnection {
  """A list of edges."""
  edges: [LoadBalancerEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerEdge {
  """The item at the end of the edge."""
  node: LoadBalancer
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancer connections"""
input LoadBalancerOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancers."""
  field: LoadBalancerOrderField!
}
"""Properties by which LoadBalancer connections can be ordered."""
enum LoadBalancerOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  NAME
  LOCATION
}
type LoadBalancerOrigin implements Node @key(fields: "id") @goModel(model: "go.infratographer.com/load-balancer-api/internal/ent/generated.Origin") {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  target: String!
  portNumber: Int!
  active: Boolean!
  poolID: ID!
  pool: LoadBalancerPool!
}
"""A connection to a list of items."""
type LoadBalancerOriginConnection {
  """A list of edges."""
  edges: [LoadBalancerOriginEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerOriginEdge {
  """The item at the end of the edge."""
  node: LoadBalancerOrigin
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerOrigin connections"""
input LoadBalancerOriginOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerOrigins."""
  field: LoadBalancerOriginOrderField!
}
"""Properties by which LoadBalancerOrigin connections can be ordered."""
enum LoadBalancerOriginOrderField {
  CREATED_AT
  UPDATED_AT
  name
  target
  number
  active
}
"""
LoadBalancerOriginWhereInput is used for filtering Origin objects.
Input was generated by ent.
"""
input LoadBalancerOriginWhereInput {
  not: LoadBalancerOriginWhereInput
  and: [LoadBalancerOriginWhereInput!]
  or: [LoadBalancerOriginWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """target field predicates"""
  target: String
  targetNEQ: String
  targetIn: [String!]
  targetNotIn: [String!]
  targetGT: String
  targetGTE: String
  targetLT: String
  targetLTE: String
  targetContains: String
  targetHasPrefix: String
  targetHasSuffix: String
  targetEqualFold: String
  targetContainsFold: String
  """port_number field predicates"""
  portNumber: Int
  portNumberNEQ: Int
  portNumberIn: [Int!]
  portNumberNotIn: [Int!]
  portNumberGT: Int
  portNumberGTE: Int
  portNumberLT: Int
  portNumberLTE: Int
  """active field predicates"""
  active: Boolean
  activeNEQ: Boolean
  """pool edge predicates"""
  hasPool: Boolean
  hasPoolWith: [LoadBalancerPoolWhereInput!]
}
type LoadBalancerPool implements Node @key(fields: "id") @goModel(model: "go.infratographer.com/load-balancer-api/internal/ent/generated.Pool") {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  protocol: LoadBalancerPoolProtocol!
  tenantID: ID!
  ports: [LoadBalancerPort!]
  origins(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerOrigins returned from the connection."""
    orderBy: LoadBalancerOriginOrder

    """Filtering options for LoadBalancerOrigins returned from the connection."""
    where: LoadBalancerOriginWhereInput
  ): LoadBalancerOriginConnection!
}
"""A connection to a list of items."""
type LoadBalancerPoolConnection {
  """A list of edges."""
  edges: [LoadBalancerPoolEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerPoolEdge {
  """The item at the end of the edge."""
  node: LoadBalancerPool
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerPool connections"""
input LoadBalancerPoolOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerPools."""
  field: LoadBalancerPoolOrderField!
}
"""Properties by which LoadBalancerPool connections can be ordered."""
enum LoadBalancerPoolOrderField {
  CREATED_AT
  UPDATED_AT
  name
  protocol
}
"""LoadBalancerPoolProtocol is enum for the field protocol"""
enum LoadBalancerPoolProtocol @goModel(model: "go.infratographer.com/load-balancer-api/internal/ent/generated/pool.Protocol") {
  tcp
  udp
}
"""
LoadBalancerPoolWhereInput is used for filtering Pool objects.
Input was generated by ent.
"""
input LoadBalancerPoolWhereInput {
  not: LoadBalancerPoolWhereInput
  and: [LoadBalancerPoolWhereInput!]
  or: [LoadBalancerPoolWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """protocol field predicates"""
  protocol: LoadBalancerPoolProtocol
  protocolNEQ: LoadBalancerPoolProtocol
  protocolIn: [LoadBalancerPoolProtocol!]
  protocolNotIn: [LoadBalancerPoolProtocol!]
  """ports edge predicates"""
  hasPorts: Boolean
  hasPortsWith: [LoadBalancerPortWhereInput!]
  """origins edge predicates"""
  hasOrigins: Boolean
  hasOriginsWith: [LoadBalancerOriginWhereInput!]
}
type LoadBalancerPort implements Node @key(fields: "id") @goModel(model: "go.infratographer.com/load-balancer-api/internal/ent/generated.Port") {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  number: Int!
  name: String!
  loadBalancerID: ID!
  pools: [LoadBalancerPool!]
  loadBalancer: LoadBalancer!
}
"""A connection to a list of items."""
type LoadBalancerPortConnection {
  """A list of edges."""
  edges: [LoadBalancerPortEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerPortEdge {
  """The item at the end of the edge."""
  node: LoadBalancerPort
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerPort connections"""
input LoadBalancerPortOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerPorts."""
  field: LoadBalancerPortOrderField!
}
"""Properties by which LoadBalancerPort connections can be ordered."""
enum LoadBalancerPortOrderField {
  CREATED_AT
  UPDATED_AT
  number
  name
}
"""
LoadBalancerPortWhereInput is used for filtering Port objects.
Input was generated by ent.
"""
input LoadBalancerPortWhereInput {
  not: LoadBalancerPortWhereInput
  and: [LoadBalancerPortWhereInput!]
  or: [LoadBalancerPortWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """number field predicates"""
  number: Int
  numberNEQ: Int
  numberIn: [Int!]
  numberNotIn: [Int!]
  numberGT: Int
  numberGTE: Int
  numberLT: Int
  numberLTE: Int
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """pools edge predicates"""
  hasPools: Boolean
  hasPoolsWith: [LoadBalancerPoolWhereInput!]
  """load_balancer edge predicates"""
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
type LoadBalancerProvider implements Node @key(fields: "id") @goModel(model: "go.infratographer.com/load-balancer-api/internal/ent/generated.Provider") {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  tenantID: ID!
  loadBalancers(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancers returned from the connection."""
    orderBy: LoadBalancerOrder

    """Filtering options for LoadBalancers returned from the connection."""
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection!
}
"""A connection to a list of items."""
type LoadBalancerProviderConnection {
  """A list of edges."""
  edges: [LoadBalancerProviderEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerProviderEdge {
  """The item at the end of the edge."""
  node: LoadBalancerProvider
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerProvider connections"""
input LoadBalancerProviderOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerProviders."""
  field: LoadBalancerProviderOrderField!
}
"""Properties by which LoadBalancerProvider connections can be ordered."""
enum LoadBalancerProviderOrderField {
  CREATED_AT
  UPDATED_AT
}
"""
LoadBalancerProviderWhereInput is used for filtering Provider objects.
Input was generated by ent.
"""
input LoadBalancerProviderWhereInput {
  not: LoadBalancerProviderWhereInput
  and: [LoadBalancerProviderWhereInput!]
  or: [LoadBalancerProviderWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """load_balancers edge predicates"""
  hasLoadBalancers: Boolean
  hasLoadBalancersWith: [LoadBalancerWhereInput!]
}
type LoadBalancerStatus implements Node @key(fields: "id") {
  id: ID!
  namespace: String!
  data: JSON!
  createdAt: Time!
  updatedAt: Time!
  loadBalancerID: ID!
  source: String!
  loadBalancer: LoadBalancer!
}
"""A connection to a list of items."""
type LoadBalancerStatusConnection {
  """A list of edges."""
  edges: [LoadBalancerStatusEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LoadBalancerStatusEdge {
  """The item at the end of the edge."""
  node: LoadBalancerStatus
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for LoadBalancerStatus connections"""
input LoadBalancerStatusOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order LoadBalancerStatusSlice."""
  field: LoadBalancerStatusOrderField!
}
"""Properties by which LoadBalancerStatus connections can be ordered."""
enum LoadBalancerStatusOrderField {
  NAMESPACE
  CREATED_AT
  UPDATED_AT
}
"""
LoadBalancerStatusWhereInput is used for filtering LoadBalancerStatus objects.
Input was generated by ent.
"""
input LoadBalancerStatusWhereInput {
  not: LoadBalancerStatusWhereInput
  and: [LoadBalancerStatusWhereInput!]
  or: [LoadBalancerStatusWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """namespace field predicates"""
  namespace: String
  namespaceNEQ: String
  namespaceIn: [String!]
  namespaceNotIn: [String!]
  namespaceGT: String
  namespaceGTE: String
  namespaceLT: String
  namespaceLTE: String
  namespaceContains: String
  namespaceHasPrefix: String
  namespaceHasSuffix: String
  namespaceEqualFold: String
  namespaceContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """source field predicates"""
  source: String
  sourceNEQ: String
  sourceIn: [String!]
  sourceNotIn: [String!]
  sourceGT: String
  sourceGTE: String
  sourceLT: String
  sourceLTE: String
  sourceContains: String
  sourceHasPrefix: String
  sourceHasSuffix: String
  sourceEqualFold: String
  sourceContainsFold: String
  """load_balancer edge predicates"""
  hasLoadBalancer: Boolean
  hasLoadBalancerWith: [LoadBalancerWhereInput!]
}
"""
LoadBalancerWhereInput is used for filtering LoadBalancer objects.
Input was generated by ent.
"""
input LoadBalancerWhereInput {
  not: LoadBalancerWhereInput
  and: [LoadBalancerWhereInput!]
  or: [LoadBalancerWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """annotations edge predicates"""
  hasAnnotations: Boolean
  hasAnnotationsWith: [LoadBalancerAnnotationWhereInput!]
  """statuses edge predicates"""
  hasStatuses: Boolean
  hasStatusesWith: [LoadBalancerStatusWhereInput!]
  """provider edge predicates"""
  hasProvider: Boolean
  hasProviderWith: [LoadBalancerProviderWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  loadBalancerPools(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerPools returned from the connection."""
    orderBy: LoadBalancerPoolOrder

    """Filtering options for LoadBalancerPools returned from the connection."""
    where: LoadBalancerPoolWhereInput
  ): LoadBalancerPoolConnection!
  loadBalancerProviders(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerProviders returned from the connection."""
    orderBy: LoadBalancerProviderOrder

    """Filtering options for LoadBalancerProviders returned from the connection."""
    where: LoadBalancerProviderWhereInput
  ): LoadBalancerProviderConnection!
}
"""The builtin Time type"""
scalar Time
"""
UpdateLoadBalancerInput is used for update LoadBalancer object.
Input was generated by ent.
"""
input UpdateLoadBalancerInput {
  name: String
  addAnnotationIDs: [ID!]
  removeAnnotationIDs: [ID!]
  clearAnnotations: Boolean
  addStatusIDs: [ID!]
  removeStatusIDs: [ID!]
  clearStatuses: Boolean
}
"""
UpdateLoadBalancerOriginInput is used for update LoadBalancerOrigin object.
Input was generated by ent.
"""
input UpdateLoadBalancerOriginInput {
  name: String
  target: String
  portNumber: Int
  active: Boolean
}
"""
UpdateLoadBalancerPoolInput is used for update LoadBalancerPool object.
Input was generated by ent.
"""
input UpdateLoadBalancerPoolInput {
  name: String
  protocol: LoadBalancerPoolProtocol
  addPortIDs: [ID!]
  removePortIDs: [ID!]
  clearPorts: Boolean
  addOriginIDs: [ID!]
  removeOriginIDs: [ID!]
  clearOrigins: Boolean
}
"""
UpdateLoadBalancerPortInput is used for update LoadBalancerPort object.
Input was generated by ent.
"""
input UpdateLoadBalancerPortInput {
  number: Int
  name: String
  addPoolIDs: [ID!]
  removePoolIDs: [ID!]
  clearPools: Boolean
}
"""
UpdateLoadBalancerProviderInput is used for update LoadBalancerProvider object.
Input was generated by ent.
"""
input UpdateLoadBalancerProviderInput {
  name: String
  addLoadBalancerIDs: [ID!]
  removeLoadBalancerIDs: [ID!]
  clearLoadBalancers: Boolean
}
`, BuiltIn: false},
	{Name: "../../schema/ipam.graphql", Input: `extend interface IPv4Addressable {
  id: ID!
}
`, BuiltIn: false},
	{Name: "../../schema/loadbalancer_mutation.graphql", Input: `extend type Mutation {
  createLoadBalancer(input: CreateLoadBalancerInput!): LoadBalancer!
  updateLoadBalancer(id: ID!, input: UpdateLoadBalancerInput!): LoadBalancer!
}
`, BuiltIn: false},
	{Name: "../../schema/location.graphql", Input: `extend type Location @key(fields: "id") {
  id: ID! @external
  loadBalancers(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancers returned from the connection."""
    orderBy: LoadBalancerOrder

    """Filtering options for LoadBalancers returned from the connection."""
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection! @goField(forceResolver: true)
}

extend type LoadBalancer {
  location: Location!
}
`, BuiltIn: false},
	{Name: "../../schema/provider_mutation.graphql", Input: `extend type Mutation {
  createLoadBalancerProvider(input: CreateLoadBalancerProviderInput!): LoadBalancerProvider!
  updateLoadBalancerProvider(id: ID!, input: UpdateLoadBalancerProviderInput!): LoadBalancerProvider!
}
`, BuiltIn: false},
	{Name: "../../schema/tenant.graphql", Input: `extend type Tenant @key(fields: "id") {
  id: ID! @external
  loadBalancers(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancers returned from the connection."""
    orderBy: LoadBalancerOrder

    """Filtering options for LoadBalancers returned from the connection."""
    where: LoadBalancerWhereInput
  ): LoadBalancerConnection! @goField(forceResolver: true)
  loadBalancerPools(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for LoadBalancerPools returned from the connection."""
    orderBy: LoadBalancerPoolOrder

    """Filtering options for LoadBalancerPools returned from the connection."""
    where: LoadBalancerPoolWhereInput
  ): LoadBalancerPoolConnection! @goField(forceResolver: true)
}

extend type LoadBalancer {
  tenant: Tenant!
}

extend type LoadBalancerPool {
  tenant: Tenant!
}
`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	scalar _Any
	scalar _FieldSet
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE

	directive @key(fields: _FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @external on FIELD_DEFINITION | OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @shareable on OBJECT | FIELD_DEFINITION
	directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
	directive @override(from: String!) on FIELD_DEFINITION
	directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
# a union of all types that use the @key directive
union _Entity = LoadBalancer | LoadBalancerAnnotation | LoadBalancerOrigin | LoadBalancerPool | LoadBalancerPort | LoadBalancerProvider | LoadBalancerStatus | Location | Tenant

# fake type to build resolver interfaces for users to implement
type Entity {
		findLoadBalancerByID(id: ID!,): LoadBalancer!
	findLoadBalancerAnnotationByID(id: ID!,): LoadBalancerAnnotation!
	findLoadBalancerOriginByID(id: ID!,): LoadBalancerOrigin!
	findLoadBalancerPoolByID(id: ID!,): LoadBalancerPool!
	findLoadBalancerPortByID(id: ID!,): LoadBalancerPort!
	findLoadBalancerProviderByID(id: ID!,): LoadBalancerProvider!
	findLoadBalancerStatusByID(id: ID!,): LoadBalancerStatus!
	findLocationByID(id: ID!,): Location!
	findTenantByID(id: ID!,): Tenant!

}

type _Service {
  sdl: String
}

extend type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Entity_findLoadBalancerAnnotationByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerOriginByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerPoolByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerPortByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerProviderByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLoadBalancerStatusByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLocationByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findTenantByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_LoadBalancerPool_origins_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerOriginOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerOriginOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerOriginWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerOriginWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_LoadBalancerProvider_loadBalancers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_LoadBalancer_annotations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerAnnotationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerAnnotationOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerAnnotationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerAnnotationWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_LoadBalancer_statuses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerStatusOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerStatusOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerStatusWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerStatusWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Location_loadBalancers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_createLoadBalancerProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateLoadBalancerProviderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLoadBalancerProviderInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐCreateLoadBalancerProviderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLoadBalancer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateLoadBalancerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLoadBalancerInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐCreateLoadBalancerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLoadBalancerProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateLoadBalancerProviderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateLoadBalancerProviderInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐUpdateLoadBalancerProviderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLoadBalancer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gidx.PrefixedID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateLoadBalancerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateLoadBalancerInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐUpdateLoadBalancerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__entities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []map[string]interface{}
	if tmp, ok := rawArgs["representations"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("representations"))
		arg0, err = ec.unmarshalN_Any2ᚕmapᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["representations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_loadBalancerPools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerPoolOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerPoolOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerPoolWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_loadBalancerProviders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerProviderOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerProviderOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerProviderWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerProviderWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Tenant_loadBalancerPools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerPoolOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerPoolOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerPoolWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Tenant_loadBalancers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[gidx.PrefixedID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.LoadBalancerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLoadBalancerOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.LoadBalancerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Entity_findLoadBalancerByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerAnnotationByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerAnnotationByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerAnnotationByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerAnnotation)
	fc.Result = res
	return ec.marshalNLoadBalancerAnnotation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerAnnotationByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerAnnotation_id(ctx, field)
			case "namespace":
				return ec.fieldContext_LoadBalancerAnnotation_namespace(ctx, field)
			case "data":
				return ec.fieldContext_LoadBalancerAnnotation_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerAnnotation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerAnnotation_updatedAt(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerAnnotation_loadBalancerID(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerAnnotation_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerAnnotation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerAnnotationByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerOriginByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerOriginByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerOriginByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Origin)
	fc.Result = res
	return ec.marshalNLoadBalancerOrigin2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐOrigin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerOriginByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerOrigin_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerOrigin_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerOrigin_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerOrigin_name(ctx, field)
			case "target":
				return ec.fieldContext_LoadBalancerOrigin_target(ctx, field)
			case "portNumber":
				return ec.fieldContext_LoadBalancerOrigin_portNumber(ctx, field)
			case "active":
				return ec.fieldContext_LoadBalancerOrigin_active(ctx, field)
			case "poolID":
				return ec.fieldContext_LoadBalancerOrigin_poolID(ctx, field)
			case "pool":
				return ec.fieldContext_LoadBalancerOrigin_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerOrigin", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerOriginByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerPoolByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerPoolByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerPoolByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Pool)
	fc.Result = res
	return ec.marshalNLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerPoolByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPool_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPool_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPool_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPool_name(ctx, field)
			case "protocol":
				return ec.fieldContext_LoadBalancerPool_protocol(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerPool_tenantID(ctx, field)
			case "ports":
				return ec.fieldContext_LoadBalancerPool_ports(ctx, field)
			case "origins":
				return ec.fieldContext_LoadBalancerPool_origins(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancerPool_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPool", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerPoolByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerPortByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerPortByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerPortByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Port)
	fc.Result = res
	return ec.marshalNLoadBalancerPort2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerPortByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPort_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPort_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPort_updatedAt(ctx, field)
			case "number":
				return ec.fieldContext_LoadBalancerPort_number(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPort_name(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerPort_loadBalancerID(ctx, field)
			case "pools":
				return ec.fieldContext_LoadBalancerPort_pools(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerPort_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPort", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerPortByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerProviderByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerProviderByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerProviderByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Provider)
	fc.Result = res
	return ec.marshalNLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerProviderByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerProvider_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProvider", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerProviderByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLoadBalancerStatusByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLoadBalancerStatusByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLoadBalancerStatusByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerStatus)
	fc.Result = res
	return ec.marshalNLoadBalancerStatus2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLoadBalancerStatusByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerStatus_id(ctx, field)
			case "namespace":
				return ec.fieldContext_LoadBalancerStatus_namespace(ctx, field)
			case "data":
				return ec.fieldContext_LoadBalancerStatus_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerStatus_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerStatus_updatedAt(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerStatus_loadBalancerID(ctx, field)
			case "source":
				return ec.fieldContext_LoadBalancerStatus_source(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerStatus_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLoadBalancerStatusByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLocationByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLocationByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLocationByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLocationByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_Location_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLocationByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findTenantByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findTenantByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindTenantByID(rctx, fc.Args["id"].(gidx.PrefixedID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalNTenant2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findTenantByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_Tenant_loadBalancers(ctx, field)
			case "loadBalancerPools":
				return ec.fieldContext_Tenant_loadBalancerPools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findTenantByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_id(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_name(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_tenantID(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_locationID(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_locationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_locationID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_annotations(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations(ctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerAnnotationOrder), fc.Args["where"].(*generated.LoadBalancerAnnotationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerAnnotationConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerAnnotationConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerAnnotationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerAnnotationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerAnnotationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerAnnotationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LoadBalancer_annotations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_statuses(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_statuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statuses(ctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerStatusOrder), fc.Args["where"].(*generated.LoadBalancerStatusWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerStatusConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerStatusConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_statuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerStatusConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerStatusConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerStatusConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerStatusConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LoadBalancer_statuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_loadBalancerProvider(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Provider)
	fc.Result = res
	return ec.marshalNLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_loadBalancerProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerProvider_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_location(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoadBalancer().Location(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_Location_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancer_tenant(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancer_tenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoadBalancer().Tenant(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalNTenant2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancer_tenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_Tenant_loadBalancers(ctx, field)
			case "loadBalancerPools":
				return ec.fieldContext_Tenant_loadBalancerPools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_id(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_namespace(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_data(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(json.RawMessage)
	fc.Result = res
	return ec.marshalNJSON2encodingᚋjsonᚐRawMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_loadBalancerID(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_loadBalancerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_loadBalancerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotation_loadBalancer(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotation_loadBalancer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancer(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotation_loadBalancer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerAnnotationEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerAnnotationEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerAnnotationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerAnnotationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerAnnotationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotationEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerAnnotation)
	fc.Result = res
	return ec.marshalOLoadBalancerAnnotation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerAnnotation_id(ctx, field)
			case "namespace":
				return ec.fieldContext_LoadBalancerAnnotation_namespace(ctx, field)
			case "data":
				return ec.fieldContext_LoadBalancerAnnotation_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerAnnotation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerAnnotation_updatedAt(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerAnnotation_loadBalancerID(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerAnnotation_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerAnnotation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerAnnotationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerAnnotationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerAnnotationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerAnnotationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerAnnotationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalOLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_id(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_name(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_target(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_portNumber(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_portNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PortNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_portNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_active(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_poolID(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_poolID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoolID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_poolID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOrigin_pool(ctx context.Context, field graphql.CollectedField, obj *generated.Origin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOrigin_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Pool)
	fc.Result = res
	return ec.marshalNLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOrigin_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOrigin",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPool_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPool_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPool_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPool_name(ctx, field)
			case "protocol":
				return ec.fieldContext_LoadBalancerPool_protocol(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerPool_tenantID(ctx, field)
			case "ports":
				return ec.fieldContext_LoadBalancerPool_ports(ctx, field)
			case "origins":
				return ec.fieldContext_LoadBalancerPool_origins(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancerPool_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOriginConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerOriginConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOriginConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerOriginEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerOriginEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOriginConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOriginConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerOriginEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerOriginEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerOriginEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOriginConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerOriginConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOriginConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOriginConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOriginConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOriginConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerOriginConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOriginConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOriginConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOriginConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOriginEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerOriginEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOriginEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Origin)
	fc.Result = res
	return ec.marshalOLoadBalancerOrigin2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐOrigin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOriginEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOriginEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerOrigin_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerOrigin_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerOrigin_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerOrigin_name(ctx, field)
			case "target":
				return ec.fieldContext_LoadBalancerOrigin_target(ctx, field)
			case "portNumber":
				return ec.fieldContext_LoadBalancerOrigin_portNumber(ctx, field)
			case "active":
				return ec.fieldContext_LoadBalancerOrigin_active(ctx, field)
			case "poolID":
				return ec.fieldContext_LoadBalancerOrigin_poolID(ctx, field)
			case "pool":
				return ec.fieldContext_LoadBalancerOrigin_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerOrigin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerOriginEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerOriginEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerOriginEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerOriginEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerOriginEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_id(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_name(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_protocol(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(pool.Protocol)
	fc.Result = res
	return ec.marshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LoadBalancerPoolProtocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_tenantID(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_ports(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Port)
	fc.Result = res
	return ec.marshalOLoadBalancerPort2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPortᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_ports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPort_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPort_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPort_updatedAt(ctx, field)
			case "number":
				return ec.fieldContext_LoadBalancerPort_number(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPort_name(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerPort_loadBalancerID(ctx, field)
			case "pools":
				return ec.fieldContext_LoadBalancerPort_pools(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerPort_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_origins(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_origins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origins(ctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerOriginOrder), fc.Args["where"].(*generated.LoadBalancerOriginWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerOriginConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerOriginConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_origins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerOriginConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerOriginConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerOriginConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerOriginConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LoadBalancerPool_origins_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPool_tenant(ctx context.Context, field graphql.CollectedField, obj *generated.Pool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPool_tenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoadBalancerPool().Tenant(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalNTenant2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPool_tenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_Tenant_loadBalancers(ctx, field)
			case "loadBalancerPools":
				return ec.fieldContext_Tenant_loadBalancerPools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPoolConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPoolConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerPoolEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerPoolEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPoolConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerPoolEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerPoolEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPoolEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPoolConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPoolConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPoolConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPoolConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPoolConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPoolConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPoolEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPoolEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPoolEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Pool)
	fc.Result = res
	return ec.marshalOLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPoolEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPoolEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPool_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPool_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPool_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPool_name(ctx, field)
			case "protocol":
				return ec.fieldContext_LoadBalancerPool_protocol(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerPool_tenantID(ctx, field)
			case "ports":
				return ec.fieldContext_LoadBalancerPool_ports(ctx, field)
			case "origins":
				return ec.fieldContext_LoadBalancerPool_origins(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancerPool_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPoolEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPoolEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPoolEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPoolEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPoolEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_id(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_number(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_name(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_loadBalancerID(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_loadBalancerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_loadBalancerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_pools(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_pools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pools(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Pool)
	fc.Result = res
	return ec.marshalOLoadBalancerPool2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPoolᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_pools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPool_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPool_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPool_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPool_name(ctx, field)
			case "protocol":
				return ec.fieldContext_LoadBalancerPool_protocol(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerPool_tenantID(ctx, field)
			case "ports":
				return ec.fieldContext_LoadBalancerPool_ports(ctx, field)
			case "origins":
				return ec.fieldContext_LoadBalancerPool_origins(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancerPool_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPort_loadBalancer(ctx context.Context, field graphql.CollectedField, obj *generated.Port) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPort_loadBalancer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancer(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPort_loadBalancer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPort",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPortConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPortConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPortConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerPortEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerPortEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPortConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPortConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerPortEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerPortEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPortEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPortConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPortConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPortConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPortConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPortConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPortConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPortConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPortConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPortConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPortConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPortEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPortEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPortEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Port)
	fc.Result = res
	return ec.marshalOLoadBalancerPort2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPortEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPortEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerPort_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerPort_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerPort_updatedAt(ctx, field)
			case "number":
				return ec.fieldContext_LoadBalancerPort_number(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerPort_name(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerPort_loadBalancerID(ctx, field)
			case "pools":
				return ec.fieldContext_LoadBalancerPort_pools(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerPort_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerPortEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerPortEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerPortEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerPortEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerPortEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_id(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_name(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_tenantID(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProvider_loadBalancers(ctx context.Context, field graphql.CollectedField, obj *generated.Provider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancers(ctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerOrder), fc.Args["where"].(*generated.LoadBalancerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProvider_loadBalancers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LoadBalancerProvider_loadBalancers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProviderConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProviderConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerProviderEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerProviderEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProviderConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerProviderEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerProviderEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProviderEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProviderConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProviderConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProviderConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProviderConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProviderEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerProviderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProviderEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Provider)
	fc.Result = res
	return ec.marshalOLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProviderEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProviderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerProvider_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerProviderEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerProviderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerProviderEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerProviderEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerProviderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_id(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_namespace(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_data(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(json.RawMessage)
	fc.Result = res
	return ec.marshalNJSON2encodingᚋjsonᚐRawMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_loadBalancerID(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_loadBalancerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_loadBalancerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_source(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatus_loadBalancer(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatus_loadBalancer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancer(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatus_loadBalancer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatusConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatusConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatusConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.LoadBalancerStatusEdge)
	fc.Result = res
	return ec.marshalOLoadBalancerStatusEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatusConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatusConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LoadBalancerStatusEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LoadBalancerStatusEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerStatusEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatusConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatusConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatusConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatusConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatusConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatusConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatusConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatusConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatusConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatusConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatusEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatusEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatusEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerStatus)
	fc.Result = res
	return ec.marshalOLoadBalancerStatus2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatusEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatusEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerStatus_id(ctx, field)
			case "namespace":
				return ec.fieldContext_LoadBalancerStatus_namespace(ctx, field)
			case "data":
				return ec.fieldContext_LoadBalancerStatus_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerStatus_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerStatus_updatedAt(ctx, field)
			case "loadBalancerID":
				return ec.fieldContext_LoadBalancerStatus_loadBalancerID(ctx, field)
			case "source":
				return ec.fieldContext_LoadBalancerStatus_source(ctx, field)
			case "loadBalancer":
				return ec.fieldContext_LoadBalancerStatus_loadBalancer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoadBalancerStatusEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.LoadBalancerStatusEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoadBalancerStatusEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoadBalancerStatusEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoadBalancerStatusEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_id(ctx context.Context, field graphql.CollectedField, obj *Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_loadBalancers(ctx context.Context, field graphql.CollectedField, obj *Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_loadBalancers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Location().LoadBalancers(rctx, obj, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerOrder), fc.Args["where"].(*generated.LoadBalancerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_loadBalancers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Location_loadBalancers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLoadBalancer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLoadBalancer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLoadBalancer(rctx, fc.Args["input"].(generated.CreateLoadBalancerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLoadBalancer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLoadBalancer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLoadBalancer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLoadBalancer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLoadBalancer(rctx, fc.Args["id"].(gidx.PrefixedID), fc.Args["input"].(generated.UpdateLoadBalancerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancer)
	fc.Result = res
	return ec.marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLoadBalancer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancer_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancer_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancer_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancer_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancer_tenantID(ctx, field)
			case "locationID":
				return ec.fieldContext_LoadBalancer_locationID(ctx, field)
			case "annotations":
				return ec.fieldContext_LoadBalancer_annotations(ctx, field)
			case "statuses":
				return ec.fieldContext_LoadBalancer_statuses(ctx, field)
			case "loadBalancerProvider":
				return ec.fieldContext_LoadBalancer_loadBalancerProvider(ctx, field)
			case "location":
				return ec.fieldContext_LoadBalancer_location(ctx, field)
			case "tenant":
				return ec.fieldContext_LoadBalancer_tenant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLoadBalancer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLoadBalancerProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLoadBalancerProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLoadBalancerProvider(rctx, fc.Args["input"].(generated.CreateLoadBalancerProviderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Provider)
	fc.Result = res
	return ec.marshalNLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLoadBalancerProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerProvider_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProvider", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLoadBalancerProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLoadBalancerProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLoadBalancerProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLoadBalancerProvider(rctx, fc.Args["id"].(gidx.PrefixedID), fc.Args["input"].(generated.UpdateLoadBalancerProviderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Provider)
	fc.Result = res
	return ec.marshalNLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLoadBalancerProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LoadBalancerProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_LoadBalancerProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_LoadBalancerProvider_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_LoadBalancerProvider_name(ctx, field)
			case "tenantID":
				return ec.fieldContext_LoadBalancerProvider_tenantID(ctx, field)
			case "loadBalancers":
				return ec.fieldContext_LoadBalancerProvider_loadBalancers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProvider", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLoadBalancerProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[gidx.PrefixedID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[gidx.PrefixedID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[gidx.PrefixedID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[gidx.PrefixedID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[gidx.PrefixedID])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_loadBalancerPools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_loadBalancerPools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LoadBalancerPools(rctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerPoolOrder), fc.Args["where"].(*generated.LoadBalancerPoolWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerPoolConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerPoolConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_loadBalancerPools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerPoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerPoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerPoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_loadBalancerPools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_loadBalancerProviders(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_loadBalancerProviders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LoadBalancerProviders(rctx, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerProviderOrder), fc.Args["where"].(*generated.LoadBalancerProviderWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerProviderConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerProviderConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_loadBalancerProviders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerProviderConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerProviderConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerProviderConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerProviderConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_loadBalancerProviders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query__entities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__entities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve_entities(ctx, fc.Args["representations"].([]map[string]interface{})), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]fedruntime.Entity)
	fc.Result = res
	return ec.marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__entities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type _Entity does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query__entities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_id(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(gidx.PrefixedID)
	fc.Result = res
	return ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_loadBalancers(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_loadBalancers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tenant().LoadBalancers(rctx, obj, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerOrder), fc.Args["where"].(*generated.LoadBalancerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_loadBalancers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Tenant_loadBalancers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_loadBalancerPools(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_loadBalancerPools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tenant().LoadBalancerPools(rctx, obj, fc.Args["after"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[gidx.PrefixedID]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.LoadBalancerPoolOrder), fc.Args["where"].(*generated.LoadBalancerPoolWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.LoadBalancerPoolConnection)
	fc.Result = res
	return ec.marshalNLoadBalancerPoolConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_loadBalancerPools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LoadBalancerPoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LoadBalancerPoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LoadBalancerPoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoadBalancerPoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Tenant_loadBalancerPools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateLoadBalancerInput(ctx context.Context, obj interface{}) (generated.CreateLoadBalancerInput, error) {
	var it generated.CreateLoadBalancerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "tenantID", "locationID", "annotationIDs", "statusIDs", "providerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
			it.TenantID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationID"))
			it.LocationID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "annotationIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotationIDs"))
			it.AnnotationIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "statusIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusIDs"))
			it.StatusIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "providerID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerID"))
			it.ProviderID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLoadBalancerOriginInput(ctx context.Context, obj interface{}) (generated.CreateLoadBalancerOriginInput, error) {
	var it generated.CreateLoadBalancerOriginInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "target", "portNumber", "active", "poolID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			it.Target, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumber"))
			it.PortNumber, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			it.Active, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolID"))
			it.PoolID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLoadBalancerPoolInput(ctx context.Context, obj interface{}) (generated.CreateLoadBalancerPoolInput, error) {
	var it generated.CreateLoadBalancerPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "protocol", "tenantID", "portIDs", "originIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			it.Protocol, err = ec.unmarshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
			it.TenantID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "portIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portIDs"))
			it.PortIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "originIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originIDs"))
			it.OriginIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLoadBalancerPortInput(ctx context.Context, obj interface{}) (generated.CreateLoadBalancerPortInput, error) {
	var it generated.CreateLoadBalancerPortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"number", "name", "poolIDs", "loadBalancerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("number"))
			it.Number, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolIDs"))
			it.PoolIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "loadBalancerID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loadBalancerID"))
			it.LoadBalancerID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLoadBalancerProviderInput(ctx context.Context, obj interface{}) (generated.CreateLoadBalancerProviderInput, error) {
	var it generated.CreateLoadBalancerProviderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "tenantID", "loadBalancerIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
			it.TenantID, err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "loadBalancerIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loadBalancerIDs"))
			it.LoadBalancerIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerAnnotationOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerAnnotationOrder, error) {
	var it generated.LoadBalancerAnnotationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerAnnotationOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerAnnotationWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerAnnotationWhereInput, error) {
	var it generated.LoadBalancerAnnotationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "namespace", "namespaceNEQ", "namespaceIn", "namespaceNotIn", "namespaceGT", "namespaceGTE", "namespaceLT", "namespaceLTE", "namespaceContains", "namespaceHasPrefix", "namespaceHasSuffix", "namespaceEqualFold", "namespaceContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "hasLoadBalancer", "hasLoadBalancerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerAnnotationWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerAnnotationWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerAnnotationWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceNEQ"))
			it.NamespaceNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceIn"))
			it.NamespaceIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceNotIn"))
			it.NamespaceNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceGT"))
			it.NamespaceGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceGTE"))
			it.NamespaceGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceLT"))
			it.NamespaceLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceLTE"))
			it.NamespaceLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceContains"))
			it.NamespaceContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceHasPrefix"))
			it.NamespaceHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceHasSuffix"))
			it.NamespaceHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceEqualFold"))
			it.NamespaceEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceContainsFold"))
			it.NamespaceContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancer"))
			it.HasLoadBalancer, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancerWith"))
			it.HasLoadBalancerWith, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerOrder, error) {
	var it generated.LoadBalancerOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerOriginOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerOriginOrder, error) {
	var it generated.LoadBalancerOriginOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerOriginOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerOriginWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerOriginWhereInput, error) {
	var it generated.LoadBalancerOriginWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "target", "targetNEQ", "targetIn", "targetNotIn", "targetGT", "targetGTE", "targetLT", "targetLTE", "targetContains", "targetHasPrefix", "targetHasSuffix", "targetEqualFold", "targetContainsFold", "portNumber", "portNumberNEQ", "portNumberIn", "portNumberNotIn", "portNumberGT", "portNumberGTE", "portNumberLT", "portNumberLTE", "active", "activeNEQ", "hasPool", "hasPoolWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerOriginWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerOriginWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerOriginWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			it.Target, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetNEQ"))
			it.TargetNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetIn"))
			it.TargetIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetNotIn"))
			it.TargetNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetGT"))
			it.TargetGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetGTE"))
			it.TargetGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetLT"))
			it.TargetLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetLTE"))
			it.TargetLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetContains"))
			it.TargetContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetHasPrefix"))
			it.TargetHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetHasSuffix"))
			it.TargetHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetEqualFold"))
			it.TargetEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetContainsFold"))
			it.TargetContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumber"))
			it.PortNumber, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberNEQ"))
			it.PortNumberNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberIn"))
			it.PortNumberIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberNotIn"))
			it.PortNumberNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberGT"))
			it.PortNumberGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberGTE"))
			it.PortNumberGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberLT"))
			it.PortNumberLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumberLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumberLTE"))
			it.PortNumberLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			it.Active, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "activeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("activeNEQ"))
			it.ActiveNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPool":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPool"))
			it.HasPool, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPoolWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPoolWith"))
			it.HasPoolWith, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerPoolOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerPoolOrder, error) {
	var it generated.LoadBalancerPoolOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerPoolOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerPoolWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerPoolWhereInput, error) {
	var it generated.LoadBalancerPoolWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "protocol", "protocolNEQ", "protocolIn", "protocolNotIn", "hasPorts", "hasPortsWith", "hasOrigins", "hasOriginsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			it.Protocol, err = ec.unmarshalOLoadBalancerPoolProtocol2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocolNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocolNEQ"))
			it.ProtocolNEQ, err = ec.unmarshalOLoadBalancerPoolProtocol2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocolIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocolIn"))
			it.ProtocolIn, err = ec.unmarshalOLoadBalancerPoolProtocol2ᚕgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocolᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocolNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocolNotIn"))
			it.ProtocolNotIn, err = ec.unmarshalOLoadBalancerPoolProtocol2ᚕgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocolᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPorts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPorts"))
			it.HasPorts, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPortsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPortsWith"))
			it.HasPortsWith, err = ec.unmarshalOLoadBalancerPortWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOrigins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrigins"))
			it.HasOrigins, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOriginsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOriginsWith"))
			it.HasOriginsWith, err = ec.unmarshalOLoadBalancerOriginWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerPortOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerPortOrder, error) {
	var it generated.LoadBalancerPortOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerPortOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerPortWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerPortWhereInput, error) {
	var it generated.LoadBalancerPortWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "number", "numberNEQ", "numberIn", "numberNotIn", "numberGT", "numberGTE", "numberLT", "numberLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasPools", "hasPoolsWith", "hasLoadBalancer", "hasLoadBalancerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerPortWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerPortWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerPortWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("number"))
			it.Number, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberNEQ"))
			it.NumberNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberIn"))
			it.NumberIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberNotIn"))
			it.NumberNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberGT"))
			it.NumberGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberGTE"))
			it.NumberGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberLT"))
			it.NumberLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "numberLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numberLTE"))
			it.NumberLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPools":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPools"))
			it.HasPools, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPoolsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPoolsWith"))
			it.HasPoolsWith, err = ec.unmarshalOLoadBalancerPoolWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancer"))
			it.HasLoadBalancer, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancerWith"))
			it.HasLoadBalancerWith, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerProviderOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerProviderOrder, error) {
	var it generated.LoadBalancerProviderOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerProviderOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerProviderWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerProviderWhereInput, error) {
	var it generated.LoadBalancerProviderWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasLoadBalancers", "hasLoadBalancersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerProviderWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerProviderWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerProviderWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancers"))
			it.HasLoadBalancers, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancersWith"))
			it.HasLoadBalancersWith, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerStatusOrder(ctx context.Context, obj interface{}) (generated.LoadBalancerStatusOrder, error) {
	var it generated.LoadBalancerStatusOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLoadBalancerStatusOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerStatusWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerStatusWhereInput, error) {
	var it generated.LoadBalancerStatusWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "namespace", "namespaceNEQ", "namespaceIn", "namespaceNotIn", "namespaceGT", "namespaceGTE", "namespaceLT", "namespaceLTE", "namespaceContains", "namespaceHasPrefix", "namespaceHasSuffix", "namespaceEqualFold", "namespaceContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "source", "sourceNEQ", "sourceIn", "sourceNotIn", "sourceGT", "sourceGTE", "sourceLT", "sourceLTE", "sourceContains", "sourceHasPrefix", "sourceHasSuffix", "sourceEqualFold", "sourceContainsFold", "hasLoadBalancer", "hasLoadBalancerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerStatusWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerStatusWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerStatusWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceNEQ"))
			it.NamespaceNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceIn"))
			it.NamespaceIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceNotIn"))
			it.NamespaceNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceGT"))
			it.NamespaceGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceGTE"))
			it.NamespaceGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceLT"))
			it.NamespaceLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceLTE"))
			it.NamespaceLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceContains"))
			it.NamespaceContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceHasPrefix"))
			it.NamespaceHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceHasSuffix"))
			it.NamespaceHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceEqualFold"))
			it.NamespaceEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespaceContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespaceContainsFold"))
			it.NamespaceContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			it.Source, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNEQ"))
			it.SourceNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceIn"))
			it.SourceIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNotIn"))
			it.SourceNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGT"))
			it.SourceGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGTE"))
			it.SourceGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLT"))
			it.SourceLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLTE"))
			it.SourceLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContains"))
			it.SourceContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasPrefix"))
			it.SourceHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasSuffix"))
			it.SourceHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceEqualFold"))
			it.SourceEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContainsFold"))
			it.SourceContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancer"))
			it.HasLoadBalancer, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLoadBalancerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLoadBalancerWith"))
			it.HasLoadBalancerWith, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoadBalancerWhereInput(ctx context.Context, obj interface{}) (generated.LoadBalancerWhereInput, error) {
	var it generated.LoadBalancerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasAnnotations", "hasAnnotationsWith", "hasStatuses", "hasStatusesWith", "hasProvider", "hasProviderWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAnnotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAnnotations"))
			it.HasAnnotations, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAnnotationsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAnnotationsWith"))
			it.HasAnnotationsWith, err = ec.unmarshalOLoadBalancerAnnotationWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStatuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStatuses"))
			it.HasStatuses, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStatusesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStatusesWith"))
			it.HasStatusesWith, err = ec.unmarshalOLoadBalancerStatusWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProvider":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProvider"))
			it.HasProvider, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProviderWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProviderWith"))
			it.HasProviderWith, err = ec.unmarshalOLoadBalancerProviderWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLoadBalancerInput(ctx context.Context, obj interface{}) (generated.UpdateLoadBalancerInput, error) {
	var it generated.UpdateLoadBalancerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "addAnnotationIDs", "removeAnnotationIDs", "clearAnnotations", "addStatusIDs", "removeStatusIDs", "clearStatuses"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "addAnnotationIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addAnnotationIDs"))
			it.AddAnnotationIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeAnnotationIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeAnnotationIDs"))
			it.RemoveAnnotationIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearAnnotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAnnotations"))
			it.ClearAnnotations, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "addStatusIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addStatusIDs"))
			it.AddStatusIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeStatusIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeStatusIDs"))
			it.RemoveStatusIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearStatuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearStatuses"))
			it.ClearStatuses, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLoadBalancerOriginInput(ctx context.Context, obj interface{}) (generated.UpdateLoadBalancerOriginInput, error) {
	var it generated.UpdateLoadBalancerOriginInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "target", "portNumber", "active"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "target":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			it.Target, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "portNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portNumber"))
			it.PortNumber, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "active":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			it.Active, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLoadBalancerPoolInput(ctx context.Context, obj interface{}) (generated.UpdateLoadBalancerPoolInput, error) {
	var it generated.UpdateLoadBalancerPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "protocol", "addPortIDs", "removePortIDs", "clearPorts", "addOriginIDs", "removeOriginIDs", "clearOrigins"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			it.Protocol, err = ec.unmarshalOLoadBalancerPoolProtocol2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, v)
			if err != nil {
				return it, err
			}
		case "addPortIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPortIDs"))
			it.AddPortIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removePortIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removePortIDs"))
			it.RemovePortIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearPorts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPorts"))
			it.ClearPorts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "addOriginIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOriginIDs"))
			it.AddOriginIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeOriginIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeOriginIDs"))
			it.RemoveOriginIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearOrigins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOrigins"))
			it.ClearOrigins, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLoadBalancerPortInput(ctx context.Context, obj interface{}) (generated.UpdateLoadBalancerPortInput, error) {
	var it generated.UpdateLoadBalancerPortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"number", "name", "addPoolIDs", "removePoolIDs", "clearPools"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("number"))
			it.Number, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "addPoolIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPoolIDs"))
			it.AddPoolIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removePoolIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removePoolIDs"))
			it.RemovePoolIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearPools":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPools"))
			it.ClearPools, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLoadBalancerProviderInput(ctx context.Context, obj interface{}) (generated.UpdateLoadBalancerProviderInput, error) {
	var it generated.UpdateLoadBalancerProviderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "addLoadBalancerIDs", "removeLoadBalancerIDs", "clearLoadBalancers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "addLoadBalancerIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addLoadBalancerIDs"))
			it.AddLoadBalancerIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeLoadBalancerIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeLoadBalancerIDs"))
			it.RemoveLoadBalancerIDs, err = ec.unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearLoadBalancers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLoadBalancers"))
			it.ClearLoadBalancers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _IPv4Addressable(ctx context.Context, sel ast.SelectionSet, obj generated.IPv4Addressable) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case generated.LoadBalancer:
		return ec._LoadBalancer(ctx, sel, &obj)
	case *generated.LoadBalancer:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancer(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj generated.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *generated.LoadBalancer:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancer(ctx, sel, obj)
	case *generated.LoadBalancerAnnotation:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerAnnotation(ctx, sel, obj)
	case *generated.Origin:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerOrigin(ctx, sel, obj)
	case *generated.Pool:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerPool(ctx, sel, obj)
	case *generated.Port:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerPort(ctx, sel, obj)
	case *generated.Provider:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerProvider(ctx, sel, obj)
	case *generated.LoadBalancerStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerStatus(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) __Entity(ctx context.Context, sel ast.SelectionSet, obj fedruntime.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case generated.LoadBalancer:
		return ec._LoadBalancer(ctx, sel, &obj)
	case *generated.LoadBalancer:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancer(ctx, sel, obj)
	case generated.LoadBalancerAnnotation:
		return ec._LoadBalancerAnnotation(ctx, sel, &obj)
	case *generated.LoadBalancerAnnotation:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerAnnotation(ctx, sel, obj)
	case generated.Origin:
		return ec._LoadBalancerOrigin(ctx, sel, &obj)
	case *generated.Origin:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerOrigin(ctx, sel, obj)
	case generated.Pool:
		return ec._LoadBalancerPool(ctx, sel, &obj)
	case *generated.Pool:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerPool(ctx, sel, obj)
	case generated.Port:
		return ec._LoadBalancerPort(ctx, sel, &obj)
	case *generated.Port:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerPort(ctx, sel, obj)
	case generated.Provider:
		return ec._LoadBalancerProvider(ctx, sel, &obj)
	case *generated.Provider:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerProvider(ctx, sel, obj)
	case generated.LoadBalancerStatus:
		return ec._LoadBalancerStatus(ctx, sel, &obj)
	case *generated.LoadBalancerStatus:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoadBalancerStatus(ctx, sel, obj)
	case Location:
		return ec._Location(ctx, sel, &obj)
	case *Location:
		if obj == nil {
			return graphql.Null
		}
		return ec._Location(ctx, sel, obj)
	case Tenant:
		return ec._Tenant(ctx, sel, &obj)
	case *Tenant:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tenant(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var entityImplementors = []string{"Entity"}

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entityImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Entity",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entity")
		case "findLoadBalancerByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerAnnotationByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerAnnotationByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerOriginByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerOriginByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerPoolByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerPoolByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerPortByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerPortByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerProviderByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerProviderByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLoadBalancerStatusByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLoadBalancerStatusByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findLocationByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLocationByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "findTenantByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findTenantByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerImplementors = []string{"LoadBalancer", "Node", "IPv4Addressable", "_Entity"}

func (ec *executionContext) _LoadBalancer(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancer")
		case "id":

			out.Values[i] = ec._LoadBalancer_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancer_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancer_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._LoadBalancer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tenantID":

			out.Values[i] = ec._LoadBalancer_tenantID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationID":

			out.Values[i] = ec._LoadBalancer_locationID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "annotations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancer_annotations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "statuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancer_statuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "loadBalancerProvider":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancer_loadBalancerProvider(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "location":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancer_location(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tenant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancer_tenant(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerAnnotationImplementors = []string{"LoadBalancerAnnotation", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerAnnotation(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerAnnotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerAnnotationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerAnnotation")
		case "id":

			out.Values[i] = ec._LoadBalancerAnnotation_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._LoadBalancerAnnotation_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "data":

			out.Values[i] = ec._LoadBalancerAnnotation_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerAnnotation_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerAnnotation_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancerID":

			out.Values[i] = ec._LoadBalancerAnnotation_loadBalancerID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerAnnotation_loadBalancer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerAnnotationConnectionImplementors = []string{"LoadBalancerAnnotationConnection"}

func (ec *executionContext) _LoadBalancerAnnotationConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerAnnotationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerAnnotationConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerAnnotationConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerAnnotationConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerAnnotationConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerAnnotationConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerAnnotationEdgeImplementors = []string{"LoadBalancerAnnotationEdge"}

func (ec *executionContext) _LoadBalancerAnnotationEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerAnnotationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerAnnotationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerAnnotationEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerAnnotationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerAnnotationEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerConnectionImplementors = []string{"LoadBalancerConnection"}

func (ec *executionContext) _LoadBalancerConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerEdgeImplementors = []string{"LoadBalancerEdge"}

func (ec *executionContext) _LoadBalancerEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerOriginImplementors = []string{"LoadBalancerOrigin", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerOrigin(ctx context.Context, sel ast.SelectionSet, obj *generated.Origin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerOriginImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerOrigin")
		case "id":

			out.Values[i] = ec._LoadBalancerOrigin_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerOrigin_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerOrigin_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._LoadBalancerOrigin_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "target":

			out.Values[i] = ec._LoadBalancerOrigin_target(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "portNumber":

			out.Values[i] = ec._LoadBalancerOrigin_portNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "active":

			out.Values[i] = ec._LoadBalancerOrigin_active(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "poolID":

			out.Values[i] = ec._LoadBalancerOrigin_poolID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pool":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerOrigin_pool(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerOriginConnectionImplementors = []string{"LoadBalancerOriginConnection"}

func (ec *executionContext) _LoadBalancerOriginConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerOriginConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerOriginConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerOriginConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerOriginConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerOriginConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerOriginConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerOriginEdgeImplementors = []string{"LoadBalancerOriginEdge"}

func (ec *executionContext) _LoadBalancerOriginEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerOriginEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerOriginEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerOriginEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerOriginEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerOriginEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPoolImplementors = []string{"LoadBalancerPool", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerPool(ctx context.Context, sel ast.SelectionSet, obj *generated.Pool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPoolImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPool")
		case "id":

			out.Values[i] = ec._LoadBalancerPool_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerPool_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerPool_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._LoadBalancerPool_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "protocol":

			out.Values[i] = ec._LoadBalancerPool_protocol(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tenantID":

			out.Values[i] = ec._LoadBalancerPool_tenantID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ports":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerPool_ports(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "origins":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerPool_origins(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tenant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerPool_tenant(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPoolConnectionImplementors = []string{"LoadBalancerPoolConnection"}

func (ec *executionContext) _LoadBalancerPoolConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerPoolConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPoolConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPoolConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerPoolConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerPoolConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerPoolConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPoolEdgeImplementors = []string{"LoadBalancerPoolEdge"}

func (ec *executionContext) _LoadBalancerPoolEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerPoolEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPoolEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPoolEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerPoolEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerPoolEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPortImplementors = []string{"LoadBalancerPort", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerPort(ctx context.Context, sel ast.SelectionSet, obj *generated.Port) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPortImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPort")
		case "id":

			out.Values[i] = ec._LoadBalancerPort_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerPort_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerPort_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "number":

			out.Values[i] = ec._LoadBalancerPort_number(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._LoadBalancerPort_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancerID":

			out.Values[i] = ec._LoadBalancerPort_loadBalancerID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerPort_pools(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "loadBalancer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerPort_loadBalancer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPortConnectionImplementors = []string{"LoadBalancerPortConnection"}

func (ec *executionContext) _LoadBalancerPortConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerPortConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPortConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPortConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerPortConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerPortConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerPortConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerPortEdgeImplementors = []string{"LoadBalancerPortEdge"}

func (ec *executionContext) _LoadBalancerPortEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerPortEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerPortEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerPortEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerPortEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerPortEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerProviderImplementors = []string{"LoadBalancerProvider", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerProvider(ctx context.Context, sel ast.SelectionSet, obj *generated.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerProviderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerProvider")
		case "id":

			out.Values[i] = ec._LoadBalancerProvider_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerProvider_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerProvider_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._LoadBalancerProvider_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tenantID":

			out.Values[i] = ec._LoadBalancerProvider_tenantID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerProvider_loadBalancers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerProviderConnectionImplementors = []string{"LoadBalancerProviderConnection"}

func (ec *executionContext) _LoadBalancerProviderConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerProviderConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerProviderConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerProviderConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerProviderConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerProviderConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerProviderConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerProviderEdgeImplementors = []string{"LoadBalancerProviderEdge"}

func (ec *executionContext) _LoadBalancerProviderEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerProviderEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerProviderEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerProviderEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerProviderEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerProviderEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerStatusImplementors = []string{"LoadBalancerStatus", "Node", "_Entity"}

func (ec *executionContext) _LoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerStatus")
		case "id":

			out.Values[i] = ec._LoadBalancerStatus_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._LoadBalancerStatus_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "data":

			out.Values[i] = ec._LoadBalancerStatus_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._LoadBalancerStatus_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._LoadBalancerStatus_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancerID":

			out.Values[i] = ec._LoadBalancerStatus_loadBalancerID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._LoadBalancerStatus_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoadBalancerStatus_loadBalancer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerStatusConnectionImplementors = []string{"LoadBalancerStatusConnection"}

func (ec *executionContext) _LoadBalancerStatusConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerStatusConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerStatusConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerStatusConnection")
		case "edges":

			out.Values[i] = ec._LoadBalancerStatusConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LoadBalancerStatusConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LoadBalancerStatusConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loadBalancerStatusEdgeImplementors = []string{"LoadBalancerStatusEdge"}

func (ec *executionContext) _LoadBalancerStatusEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.LoadBalancerStatusEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loadBalancerStatusEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerStatusEdge")
		case "node":

			out.Values[i] = ec._LoadBalancerStatusEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LoadBalancerStatusEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var locationImplementors = []string{"Location", "_Entity"}

func (ec *executionContext) _Location(ctx context.Context, sel ast.SelectionSet, obj *Location) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Location")
		case "id":

			out.Values[i] = ec._Location_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Location_loadBalancers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createLoadBalancer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLoadBalancer(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateLoadBalancer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLoadBalancer(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createLoadBalancerProvider":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLoadBalancerProvider(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateLoadBalancerProvider":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLoadBalancerProvider(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[gidx.PrefixedID]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "loadBalancerPools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_loadBalancerPools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "loadBalancerProviders":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_loadBalancerProviders(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_entities":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__entities(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_service":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tenantImplementors = []string{"Tenant", "_Entity"}

func (ec *executionContext) _Tenant(ctx context.Context, sel ast.SelectionSet, obj *Tenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tenant")
		case "id":

			out.Values[i] = ec._Tenant_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loadBalancers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tenant_loadBalancers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "loadBalancerPools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tenant_loadBalancerPools(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":

			out.Values[i] = ec.__Service_sdl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateLoadBalancerInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐCreateLoadBalancerInput(ctx context.Context, v interface{}) (generated.CreateLoadBalancerInput, error) {
	res, err := ec.unmarshalInputCreateLoadBalancerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateLoadBalancerProviderInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐCreateLoadBalancerProviderInput(ctx context.Context, v interface{}) (generated.CreateLoadBalancerProviderInput, error) {
	res, err := ec.unmarshalInputCreateLoadBalancerProviderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (entgql.Cursor[gidx.PrefixedID], error) {
	var res entgql.Cursor[gidx.PrefixedID]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[gidx.PrefixedID]) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx context.Context, v interface{}) (gidx.PrefixedID, error) {
	var res gidx.PrefixedID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx context.Context, sel ast.SelectionSet, v gidx.PrefixedID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2encodingᚋjsonᚐRawMessage(ctx context.Context, v interface{}) (json.RawMessage, error) {
	res, err := entx.UnmarshalRawMessage(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2encodingᚋjsonᚐRawMessage(ctx context.Context, sel ast.SelectionSet, v json.RawMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := entx.MarshalRawMessage(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLoadBalancer2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancer) graphql.Marshaler {
	return ec._LoadBalancer(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancer(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerAnnotation2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotation(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancerAnnotation) graphql.Marshaler {
	return ec._LoadBalancerAnnotation(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerAnnotation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotation(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerAnnotation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerAnnotation(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerAnnotationConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerAnnotationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerAnnotationConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerAnnotationOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerAnnotationOrderField, error) {
	var res = new(generated.LoadBalancerAnnotationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerAnnotationOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerAnnotationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerAnnotationWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerAnnotationWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerAnnotationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerConnection2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerConnection(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancerConnection) graphql.Marshaler {
	return ec._LoadBalancerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerOrderField, error) {
	var res = new(generated.LoadBalancerOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNLoadBalancerOrigin2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐOrigin(ctx context.Context, sel ast.SelectionSet, v generated.Origin) graphql.Marshaler {
	return ec._LoadBalancerOrigin(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerOrigin2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐOrigin(ctx context.Context, sel ast.SelectionSet, v *generated.Origin) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerOrigin(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerOriginConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerOriginConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerOriginConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerOriginOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerOriginOrderField, error) {
	var res = new(generated.LoadBalancerOriginOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerOriginOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerOriginOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerOriginWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerOriginWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerOriginWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerPool2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx context.Context, sel ast.SelectionSet, v generated.Pool) graphql.Marshaler {
	return ec._LoadBalancerPool(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx context.Context, sel ast.SelectionSet, v *generated.Pool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerPool(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerPoolConnection2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolConnection(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancerPoolConnection) graphql.Marshaler {
	return ec._LoadBalancerPoolConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerPoolConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerPoolConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerPoolConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerPoolOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerPoolOrderField, error) {
	var res = new(generated.LoadBalancerPoolOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerPoolOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerPoolOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx context.Context, v interface{}) (pool.Protocol, error) {
	var res pool.Protocol
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx context.Context, sel ast.SelectionSet, v pool.Protocol) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerPoolWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerPoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerPort2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx context.Context, sel ast.SelectionSet, v generated.Port) graphql.Marshaler {
	return ec._LoadBalancerPort(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerPort2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx context.Context, sel ast.SelectionSet, v *generated.Port) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerPort(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerPortOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerPortOrderField, error) {
	var res = new(generated.LoadBalancerPortOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerPortOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerPortOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerPortWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerPortWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerPortWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerProvider2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx context.Context, sel ast.SelectionSet, v generated.Provider) graphql.Marshaler {
	return ec._LoadBalancerProvider(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx context.Context, sel ast.SelectionSet, v *generated.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerProvider(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerProviderConnection2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderConnection(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancerProviderConnection) graphql.Marshaler {
	return ec._LoadBalancerProviderConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerProviderConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerProviderConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerProviderConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerProviderOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerProviderOrderField, error) {
	var res = new(generated.LoadBalancerProviderOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerProviderOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerProviderOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerProviderWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerProviderWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerProviderWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerStatus2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, v generated.LoadBalancerStatus) graphql.Marshaler {
	return ec._LoadBalancerStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoadBalancerStatus2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNLoadBalancerStatusConnection2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusConnection(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerStatusConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoadBalancerStatusConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLoadBalancerStatusOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusOrderField(ctx context.Context, v interface{}) (*generated.LoadBalancerStatusOrderField, error) {
	var res = new(generated.LoadBalancerStatusOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoadBalancerStatusOrderField2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerStatusOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLoadBalancerStatusWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerStatusWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerStatusWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerWhereInput, error) {
	res, err := ec.unmarshalInputLoadBalancerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocation2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐLocation(ctx context.Context, sel ast.SelectionSet, v Location) graphql.Marshaler {
	return ec._Location(ctx, sel, &v)
}

func (ec *executionContext) marshalNLocation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐLocation(ctx context.Context, sel ast.SelectionSet, v *Location) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[gidx.PrefixedID]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTenant2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐTenant(ctx context.Context, sel ast.SelectionSet, v Tenant) graphql.Marshaler {
	return ec._Tenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNTenant2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋgraphapiᚐTenant(ctx context.Context, sel ast.SelectionSet, v *Tenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tenant(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateLoadBalancerInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐUpdateLoadBalancerInput(ctx context.Context, v interface{}) (generated.UpdateLoadBalancerInput, error) {
	res, err := ec.unmarshalInputUpdateLoadBalancerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateLoadBalancerProviderInput2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐUpdateLoadBalancerProviderInput(ctx context.Context, v interface{}) (generated.UpdateLoadBalancerProviderInput, error) {
	res, err := ec.unmarshalInputUpdateLoadBalancerProviderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalN_Any2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_Any2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN_Any2ᚕmapᚄ(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN_Any2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN_Any2ᚕmapᚄ(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalN_Any2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v []fedruntime.Entity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (*entgql.Cursor[gidx.PrefixedID], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[gidx.PrefixedID])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[gidx.PrefixedID]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx context.Context, v interface{}) ([]gidx.PrefixedID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]gidx.PrefixedID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedIDᚄ(ctx context.Context, sel ast.SelectionSet, v []gidx.PrefixedID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2goᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx context.Context, v interface{}) (*gidx.PrefixedID, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(gidx.PrefixedID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖgoᚗinfratographerᚗcomᚋxᚋgidxᚐPrefixedID(ctx context.Context, sel ast.SelectionSet, v *gidx.PrefixedID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLoadBalancer2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancer(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancer(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerAnnotation2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotation(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerAnnotation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerAnnotation(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerAnnotationEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerAnnotationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerAnnotationEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerAnnotationEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerAnnotationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerAnnotationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerAnnotationOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerAnnotationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerAnnotationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerAnnotationWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerAnnotationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerAnnotationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerAnnotationWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerAnnotationWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerAnnotationWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerAnnotationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerAnnotationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerOrigin2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐOrigin(ctx context.Context, sel ast.SelectionSet, v *generated.Origin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerOrigin(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerOriginEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerOriginEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerOriginEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerOriginEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerOriginEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerOriginEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerOriginOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerOriginOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerOriginOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerOriginWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerOriginWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerOriginWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerOriginWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerOriginWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerOriginWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerOriginWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerOriginWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerPool2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPoolᚄ(ctx context.Context, sel ast.SelectionSet, v []*generated.Pool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLoadBalancerPool2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPool(ctx context.Context, sel ast.SelectionSet, v *generated.Pool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerPool(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerPoolEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerPoolEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerPoolEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerPoolEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerPoolEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerPoolEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerPoolOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerPoolOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerPoolOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerPoolProtocol2ᚕgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocolᚄ(ctx context.Context, v interface{}) ([]pool.Protocol, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]pool.Protocol, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLoadBalancerPoolProtocol2ᚕgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocolᚄ(ctx context.Context, sel ast.SelectionSet, v []pool.Protocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLoadBalancerPoolProtocol2goᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLoadBalancerPoolProtocol2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx context.Context, v interface{}) (*pool.Protocol, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(pool.Protocol)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerPoolProtocol2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚋpoolᚐProtocol(ctx context.Context, sel ast.SelectionSet, v *pool.Protocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLoadBalancerPoolWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerPoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerPoolWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerPoolWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPoolWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerPoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerPoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerPort2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPortᚄ(ctx context.Context, sel ast.SelectionSet, v []*generated.Port) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLoadBalancerPort2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLoadBalancerPort2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐPort(ctx context.Context, sel ast.SelectionSet, v *generated.Port) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerPort(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerPortEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerPortEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerPortEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerPortEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerPortEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerPortEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerPortWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerPortWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerPortWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerPortWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerPortWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerPortWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerPortWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerPortWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerProvider2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐProvider(ctx context.Context, sel ast.SelectionSet, v *generated.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerProvider(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerProviderEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerProviderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerProviderEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerProviderEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerProviderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerProviderEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerProviderOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerProviderOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerProviderOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerProviderWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerProviderWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerProviderWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerProviderWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerProviderWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerProviderWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerProviderWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerProviderWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLoadBalancerStatus2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOLoadBalancerStatusEdge2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.LoadBalancerStatusEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLoadBalancerStatusEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLoadBalancerStatusEdge2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusEdge(ctx context.Context, sel ast.SelectionSet, v *generated.LoadBalancerStatusEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoadBalancerStatusEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoadBalancerStatusOrder2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusOrder(ctx context.Context, v interface{}) (*generated.LoadBalancerStatusOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerStatusOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerStatusWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerStatusWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerStatusWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerStatusWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerStatusWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerStatusWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerStatusWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerStatusWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLoadBalancerWhereInput2ᚕᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInputᚄ(ctx context.Context, v interface{}) ([]*generated.LoadBalancerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.LoadBalancerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLoadBalancerWhereInput2ᚖgoᚗinfratographerᚗcomᚋloadᚑbalancerᚑapiᚋinternalᚋentᚋgeneratedᚐLoadBalancerWhereInput(ctx context.Context, v interface{}) (*generated.LoadBalancerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoadBalancerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v fedruntime.Entity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.__Entity(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
