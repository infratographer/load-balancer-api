// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package pubsubhooks

import (
	"context"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"go.infratographer.com/load-balancer-api/internal/ent/generated"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/hook"
	"go.infratographer.com/load-balancer-api/internal/ent/schema"
	"go.infratographer.com/x/gidx"
	"go.infratographer.com/x/pubsubx"
	"golang.org/x/exp/slices"
)

func LoadBalancerHooks() []ent.Hook {
	return []ent.Hook{
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.LoadBalancerFunc(func(ctx context.Context, m *generated.LoadBalancerMutation) (ent.Value, error) {
					// complete the mutation before we process the event
					retValue, err := next.Mutate(ctx, m)
					if err != nil {
						return retValue, err
					}

					queueName := "load-balancers.%location_id%"
					additionalSubjects := []gidx.PrefixedID{}

					objID, ok := m.ID()
					if !ok {
						return nil, fmt.Errorf("object doesn't have an id %s", objID)
					}

					changeset := []pubsubx.FieldChange{}
					cv_created_at := ""
					created_at, ok := m.CreatedAt()

					if ok {
						cv_created_at = created_at.Format(time.RFC3339)
						pv_created_at := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldCreatedAt(ctx)
							if err != nil {
								pv_created_at = "<unknown>"
							} else {
								pv_created_at = ov.Format(time.RFC3339)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "created_at",
							PreviousValue: pv_created_at,
							CurrentValue:  cv_created_at,
						})
					}

					cv_updated_at := ""
					updated_at, ok := m.UpdatedAt()

					if ok {
						cv_updated_at = updated_at.Format(time.RFC3339)
						pv_updated_at := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldUpdatedAt(ctx)
							if err != nil {
								pv_updated_at = "<unknown>"
							} else {
								pv_updated_at = ov.Format(time.RFC3339)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "updated_at",
							PreviousValue: pv_updated_at,
							CurrentValue:  cv_updated_at,
						})
					}

					cv_name := ""
					name, ok := m.Name()

					if ok {
						cv_name = fmt.Sprintf("%s", name)
						pv_name := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldName(ctx)
							if err != nil {
								pv_name = "<unknown>"
							} else {
								pv_name = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "name",
							PreviousValue: pv_name,
							CurrentValue:  cv_name,
						})
					}

					cv_tenant_id := ""
					tenant_id, ok := m.TenantID()
					if !ok && !m.Op().Is(ent.OpCreate) {
						// since we are doing an update or delete and these fields didn't change, load the "old" value
						tenant_id, err = m.OldTenantID(ctx)
						if err != nil {
							return nil, err
						}
					}
					additionalSubjects = append(additionalSubjects, tenant_id)

					if ok {
						cv_tenant_id = fmt.Sprintf("%s", tenant_id)
						pv_tenant_id := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldTenantID(ctx)
							if err != nil {
								pv_tenant_id = "<unknown>"
							} else {
								pv_tenant_id = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "tenant_id",
							PreviousValue: pv_tenant_id,
							CurrentValue:  cv_tenant_id,
						})
					}

					cv_location_id := ""
					location_id, ok := m.LocationID()
					if !ok && !m.Op().Is(ent.OpCreate) {
						// since we are doing an update or delete and these fields didn't change, load the "old" value
						location_id, err = m.OldLocationID(ctx)
						if err != nil {
							return nil, err
						}
					}
					additionalSubjects = append(additionalSubjects, location_id)
					cv_location_id = fmt.Sprintf("%s", location_id)
					queueName = strings.ReplaceAll(queueName, "%location_id%", cv_location_id)

					if ok {
						pv_location_id := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldLocationID(ctx)
							if err != nil {
								pv_location_id = "<unknown>"
							} else {
								pv_location_id = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "location_id",
							PreviousValue: pv_location_id,
							CurrentValue:  cv_location_id,
						})
					}

					cv_provider_id := ""
					provider_id, ok := m.ProviderID()
					if !ok && !m.Op().Is(ent.OpCreate) {
						// since we are doing an update or delete and these fields didn't change, load the "old" value
						provider_id, err = m.OldProviderID(ctx)
						if err != nil {
							return nil, err
						}
					}
					additionalSubjects = append(additionalSubjects, provider_id)

					if ok {
						cv_provider_id = fmt.Sprintf("%s", provider_id)
						pv_provider_id := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldProviderID(ctx)
							if err != nil {
								pv_provider_id = "<unknown>"
							} else {
								pv_provider_id = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "provider_id",
							PreviousValue: pv_provider_id,
							CurrentValue:  cv_provider_id,
						})
					}

					msg := pubsubx.ChangeMessage{
						EventType:            eventType(m.Op()),
						SubjectID:            objID,
						AdditionalSubjectIDs: additionalSubjects,
						Timestamp:            time.Now().UTC(),
						FieldChanges:         changeset,
					}

					fmt.Println(queueName)

					lb_lookup := getLocation(ctx, objID, additionalSubjects)
					if lb_lookup != "" {
						lb, err := m.Client().LoadBalancer.Get(ctx, lb_lookup)
						if err != nil {
							return nil, fmt.Errorf("unable to lookup location %s", lb_lookup)
						}

						if !slices.Contains(additionalSubjects, lb.LocationID) {
							additionalSubjects = append(additionalSubjects, lb.LocationID)
							msg.AdditionalSubjectIDs = additionalSubjects
						}
					}

					pubSubj := m.PubsubClient.NewSubject("changes", eventType(m.Op()), eventSubject(objID))

					if err := m.PubsubClient.PublishChange(ctx, pubSubj, msg); err != nil {
						return nil, fmt.Errorf("failed to publish change: %w", err)
					}

					return retValue, nil
				})
			},
			ent.OpCreate|ent.OpUpdate|ent.OpUpdateOne,
		),

		// Delete Hook
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.LoadBalancerFunc(func(ctx context.Context, m *generated.LoadBalancerMutation) (ent.Value, error) {
					queueName := "load-balancers.%location_id%"
					additionalSubjects := []gidx.PrefixedID{}

					objID, ok := m.ID()
					if !ok {
						return nil, fmt.Errorf("object doesn't have an id %s", objID)
					}

					dbObj, err := m.Client().LoadBalancer.Get(ctx, objID)
					if err != nil {
						return nil, fmt.Errorf("failed to load object to get values for pubsub, err %w", err)
					}

					additionalSubjects = append(additionalSubjects, dbObj.TenantID)

					additionalSubjects = append(additionalSubjects, dbObj.LocationID)
					value_location_id := fmt.Sprintf("%s", dbObj.LocationID)
					queueName = strings.ReplaceAll(queueName, "%location_id%", value_location_id)

					additionalSubjects = append(additionalSubjects, dbObj.ProviderID)

					lb_lookup := getLocation(ctx, objID, additionalSubjects)
					if lb_lookup != "" {
						lb, err := m.Client().LoadBalancer.Get(ctx, lb_lookup)
						if err != nil {
							return nil, fmt.Errorf("unable to lookup location %s", lb_lookup)
						}

						if !slices.Contains(additionalSubjects, lb.LocationID) {
							additionalSubjects = append(additionalSubjects, lb.LocationID)
							// msg.AdditionalSubjectIDs = additionalSubjects
						}
					}

					// we have all the info we need, now complete the mutation before we process the event
					retValue, err := next.Mutate(ctx, m)
					if err != nil {
						return retValue, err
					}

					msg := pubsubx.ChangeMessage{
						EventType:            eventType(m.Op()),
						SubjectID:            objID,
						AdditionalSubjectIDs: additionalSubjects,
						Timestamp:            time.Now().UTC(),
					}

					fmt.Println(queueName)

					pubSubj := m.PubsubClient.NewSubject("changes", eventType(m.Op()), eventSubject(objID))

					if err := m.PubsubClient.PublishChange(ctx, pubSubj, msg); err != nil {
						return nil, fmt.Errorf("failed to publish change: %w", err)
					}

					return retValue, nil
				})
			},
			ent.OpDelete|ent.OpDeleteOne,
		),
	}
}
func PortHooks() []ent.Hook {
	return []ent.Hook{
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.PortFunc(func(ctx context.Context, m *generated.PortMutation) (ent.Value, error) {
					// complete the mutation before we process the event
					retValue, err := next.Mutate(ctx, m)
					if err != nil {
						return retValue, err
					}

					queueName := "load-balancer-port.%location_id%"
					additionalSubjects := []gidx.PrefixedID{}

					objID, ok := m.ID()
					if !ok {
						return nil, fmt.Errorf("object doesn't have an id %s", objID)
					}

					changeset := []pubsubx.FieldChange{}
					cv_created_at := ""
					created_at, ok := m.CreatedAt()

					if ok {
						cv_created_at = created_at.Format(time.RFC3339)
						pv_created_at := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldCreatedAt(ctx)
							if err != nil {
								pv_created_at = "<unknown>"
							} else {
								pv_created_at = ov.Format(time.RFC3339)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "created_at",
							PreviousValue: pv_created_at,
							CurrentValue:  cv_created_at,
						})
					}

					cv_updated_at := ""
					updated_at, ok := m.UpdatedAt()

					if ok {
						cv_updated_at = updated_at.Format(time.RFC3339)
						pv_updated_at := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldUpdatedAt(ctx)
							if err != nil {
								pv_updated_at = "<unknown>"
							} else {
								pv_updated_at = ov.Format(time.RFC3339)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "updated_at",
							PreviousValue: pv_updated_at,
							CurrentValue:  cv_updated_at,
						})
					}

					cv_number := ""
					number, ok := m.Number()

					if ok {
						cv_number = fmt.Sprintf("%s", number)
						pv_number := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldNumber(ctx)
							if err != nil {
								pv_number = "<unknown>"
							} else {
								pv_number = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "number",
							PreviousValue: pv_number,
							CurrentValue:  cv_number,
						})
					}

					cv_name := ""
					name, ok := m.Name()

					if ok {
						cv_name = fmt.Sprintf("%s", name)
						pv_name := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldName(ctx)
							if err != nil {
								pv_name = "<unknown>"
							} else {
								pv_name = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "name",
							PreviousValue: pv_name,
							CurrentValue:  cv_name,
						})
					}

					cv_load_balancer_id := ""
					load_balancer_id, ok := m.LoadBalancerID()
					if !ok && !m.Op().Is(ent.OpCreate) {
						// since we are doing an update or delete and these fields didn't change, load the "old" value
						load_balancer_id, err = m.OldLoadBalancerID(ctx)
						if err != nil {
							return nil, err
						}
					}
					additionalSubjects = append(additionalSubjects, load_balancer_id)

					if ok {
						cv_load_balancer_id = fmt.Sprintf("%s", load_balancer_id)
						pv_load_balancer_id := ""
						if !m.Op().Is(ent.OpCreate) {
							ov, err := m.OldLoadBalancerID(ctx)
							if err != nil {
								pv_load_balancer_id = "<unknown>"
							} else {
								pv_load_balancer_id = fmt.Sprintf("%s", ov)
							}
						}

						changeset = append(changeset, pubsubx.FieldChange{
							Field:         "load_balancer_id",
							PreviousValue: pv_load_balancer_id,
							CurrentValue:  cv_load_balancer_id,
						})
					}

					msg := pubsubx.ChangeMessage{
						EventType:            eventType(m.Op()),
						SubjectID:            objID,
						AdditionalSubjectIDs: additionalSubjects,
						Timestamp:            time.Now().UTC(),
						FieldChanges:         changeset,
					}

					fmt.Println(queueName)

					lb_lookup := getLocation(ctx, objID, additionalSubjects)
					if lb_lookup != "" {
						lb, err := m.Client().LoadBalancer.Get(ctx, lb_lookup)
						if err != nil {
							return nil, fmt.Errorf("unable to lookup location %s", lb_lookup)
						}

						if !slices.Contains(additionalSubjects, lb.LocationID) {
							additionalSubjects = append(additionalSubjects, lb.LocationID)
							msg.AdditionalSubjectIDs = additionalSubjects
						}
					}

					pubSubj := m.PubsubClient.NewSubject("changes", eventType(m.Op()), eventSubject(objID))

					if err := m.PubsubClient.PublishChange(ctx, pubSubj, msg); err != nil {
						return nil, fmt.Errorf("failed to publish change: %w", err)
					}

					return retValue, nil
				})
			},
			ent.OpCreate|ent.OpUpdate|ent.OpUpdateOne,
		),

		// Delete Hook
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.LoadBalancerFunc(func(ctx context.Context, m *generated.LoadBalancerMutation) (ent.Value, error) {
					queueName := "load-balancer-port.%location_id%"
					additionalSubjects := []gidx.PrefixedID{}

					objID, ok := m.ID()
					if !ok {
						return nil, fmt.Errorf("object doesn't have an id %s", objID)
					}

					dbObj, err := m.Client().Port.Get(ctx, objID)
					if err != nil {
						return nil, fmt.Errorf("failed to load object to get values for pubsub, err %w", err)
					}

					additionalSubjects = append(additionalSubjects, dbObj.LoadBalancerID)

					lb_lookup := getLocation(ctx, objID, additionalSubjects)
					if lb_lookup != "" {
						lb, err := m.Client().LoadBalancer.Get(ctx, lb_lookup)
						if err != nil {
							return nil, fmt.Errorf("unable to lookup location %s", lb_lookup)
						}

						if !slices.Contains(additionalSubjects, lb.LocationID) {
							additionalSubjects = append(additionalSubjects, lb.LocationID)
							// msg.AdditionalSubjectIDs = additionalSubjects
						}
					}

					// we have all the info we need, now complete the mutation before we process the event
					retValue, err := next.Mutate(ctx, m)
					if err != nil {
						return retValue, err
					}

					msg := pubsubx.ChangeMessage{
						EventType:            eventType(m.Op()),
						SubjectID:            objID,
						AdditionalSubjectIDs: additionalSubjects,
						Timestamp:            time.Now().UTC(),
					}

					fmt.Println(queueName)

					pubSubj := m.PubsubClient.NewSubject("changes", eventType(m.Op()), eventSubject(objID))

					if err := m.PubsubClient.PublishChange(ctx, pubSubj, msg); err != nil {
						return nil, fmt.Errorf("failed to publish change: %w", err)
					}

					return retValue, nil
				})
			},
			ent.OpDelete|ent.OpDeleteOne,
		),
	}
}

func PubsubHooks(c *generated.Client) {
	c.LoadBalancer.Use(LoadBalancerHooks()...)

	c.Port.Use(PortHooks()...)

}

func eventType(op ent.Op) string {
	switch op {
	case ent.OpCreate:
		return "create"
	case ent.OpUpdate, ent.OpUpdateOne:
		return "update"
	case ent.OpDelete, ent.OpDeleteOne:
		return "delete"
	default:
		return "unknown"
	}
}

func eventSubject(objID gidx.PrefixedID) string {
	switch objID.Prefix() {
	case schema.LoadBalancerPrefix:
		return "load-balancer"
	case schema.PortPrefix:
		return "load-balancer-port"
	case schema.OriginPrefix:
		return "load-balancer-origin"
	case schema.PoolPrefix:
		return "load-balancer-pool"
	default:
		return "unknown"
	}
}

func getLocation(ctx context.Context, id gidx.PrefixedID, addID []gidx.PrefixedID) gidx.PrefixedID {
	if id.Prefix() == schema.LoadBalancerPrefix {
		return id
	}

	for _, id := range addID {
		if id.Prefix() == schema.LoadBalancerPrefix {
			return id
		}
	}

	return ""
}
