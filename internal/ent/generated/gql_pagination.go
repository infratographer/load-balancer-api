// Copyright 2023 The Infratographer Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/loadbalancer"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/origin"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/pool"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/port"
	"go.infratographer.com/load-balancer-api/internal/ent/generated/provider"
	"go.infratographer.com/x/gidx"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[gidx.PrefixedID]
	PageInfo       = entgql.PageInfo[gidx.PrefixedID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// LoadBalancerEdge is the edge representation of LoadBalancer.
type LoadBalancerEdge struct {
	Node   *LoadBalancer `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// LoadBalancerConnection is the connection containing edges to LoadBalancer.
type LoadBalancerConnection struct {
	Edges      []*LoadBalancerEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *LoadBalancerConnection) build(nodes []*LoadBalancer, pager *loadbalancerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LoadBalancer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LoadBalancer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LoadBalancer {
			return nodes[i]
		}
	}
	c.Edges = make([]*LoadBalancerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LoadBalancerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LoadBalancerPaginateOption enables pagination customization.
type LoadBalancerPaginateOption func(*loadbalancerPager) error

// WithLoadBalancerOrder configures pagination ordering.
func WithLoadBalancerOrder(order *LoadBalancerOrder) LoadBalancerPaginateOption {
	if order == nil {
		order = DefaultLoadBalancerOrder
	}
	o := *order
	return func(pager *loadbalancerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLoadBalancerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLoadBalancerFilter configures pagination filter.
func WithLoadBalancerFilter(filter func(*LoadBalancerQuery) (*LoadBalancerQuery, error)) LoadBalancerPaginateOption {
	return func(pager *loadbalancerPager) error {
		if filter == nil {
			return errors.New("LoadBalancerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type loadbalancerPager struct {
	reverse bool
	order   *LoadBalancerOrder
	filter  func(*LoadBalancerQuery) (*LoadBalancerQuery, error)
}

func newLoadBalancerPager(opts []LoadBalancerPaginateOption, reverse bool) (*loadbalancerPager, error) {
	pager := &loadbalancerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLoadBalancerOrder
	}
	return pager, nil
}

func (p *loadbalancerPager) applyFilter(query *LoadBalancerQuery) (*LoadBalancerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *loadbalancerPager) toCursor(lb *LoadBalancer) Cursor {
	return p.order.Field.toCursor(lb)
}

func (p *loadbalancerPager) applyCursors(query *LoadBalancerQuery, after, before *Cursor) (*LoadBalancerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLoadBalancerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *loadbalancerPager) applyOrder(query *LoadBalancerQuery) *LoadBalancerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLoadBalancerOrder.Field {
		query = query.Order(DefaultLoadBalancerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *loadbalancerPager) orderExpr(query *LoadBalancerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLoadBalancerOrder.Field {
			b.Comma().Ident(DefaultLoadBalancerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LoadBalancer.
func (lb *LoadBalancerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LoadBalancerPaginateOption,
) (*LoadBalancerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLoadBalancerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if lb, err = pager.applyFilter(lb); err != nil {
		return nil, err
	}
	conn := &LoadBalancerConnection{Edges: []*LoadBalancerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = lb.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if lb, err = pager.applyCursors(lb, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		lb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := lb.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	lb = pager.applyOrder(lb)
	nodes, err := lb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LoadBalancerOrderFieldID orders LoadBalancer by id.
	LoadBalancerOrderFieldID = &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.ID, nil
		},
		column: loadbalancer.FieldID,
		toTerm: loadbalancer.ByID,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{
				ID:    lb.ID,
				Value: lb.ID,
			}
		},
	}
	// LoadBalancerOrderFieldCreatedAt orders LoadBalancer by created_at.
	LoadBalancerOrderFieldCreatedAt = &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.CreatedAt, nil
		},
		column: loadbalancer.FieldCreatedAt,
		toTerm: loadbalancer.ByCreatedAt,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{
				ID:    lb.ID,
				Value: lb.CreatedAt,
			}
		},
	}
	// LoadBalancerOrderFieldUpdatedAt orders LoadBalancer by updated_at.
	LoadBalancerOrderFieldUpdatedAt = &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.UpdatedAt, nil
		},
		column: loadbalancer.FieldUpdatedAt,
		toTerm: loadbalancer.ByUpdatedAt,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{
				ID:    lb.ID,
				Value: lb.UpdatedAt,
			}
		},
	}
	// LoadBalancerOrderFieldName orders LoadBalancer by name.
	LoadBalancerOrderFieldName = &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.Name, nil
		},
		column: loadbalancer.FieldName,
		toTerm: loadbalancer.ByName,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{
				ID:    lb.ID,
				Value: lb.Name,
			}
		},
	}
	// LoadBalancerOrderFieldOwnerID orders LoadBalancer by owner_id.
	LoadBalancerOrderFieldOwnerID = &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.OwnerID, nil
		},
		column: loadbalancer.FieldOwnerID,
		toTerm: loadbalancer.ByOwnerID,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{
				ID:    lb.ID,
				Value: lb.OwnerID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LoadBalancerOrderField) String() string {
	var str string
	switch f.column {
	case LoadBalancerOrderFieldID.column:
		str = "ID"
	case LoadBalancerOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case LoadBalancerOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case LoadBalancerOrderFieldName.column:
		str = "NAME"
	case LoadBalancerOrderFieldOwnerID.column:
		str = "OWNER"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LoadBalancerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LoadBalancerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LoadBalancerOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *LoadBalancerOrderFieldID
	case "CREATED_AT":
		*f = *LoadBalancerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *LoadBalancerOrderFieldUpdatedAt
	case "NAME":
		*f = *LoadBalancerOrderFieldName
	case "OWNER":
		*f = *LoadBalancerOrderFieldOwnerID
	default:
		return fmt.Errorf("%s is not a valid LoadBalancerOrderField", str)
	}
	return nil
}

// LoadBalancerOrderField defines the ordering field of LoadBalancer.
type LoadBalancerOrderField struct {
	// Value extracts the ordering value from the given LoadBalancer.
	Value    func(*LoadBalancer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) loadbalancer.OrderOption
	toCursor func(*LoadBalancer) Cursor
}

// LoadBalancerOrder defines the ordering of LoadBalancer.
type LoadBalancerOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *LoadBalancerOrderField `json:"field"`
}

// DefaultLoadBalancerOrder is the default ordering of LoadBalancer.
var DefaultLoadBalancerOrder = &LoadBalancerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LoadBalancerOrderField{
		Value: func(lb *LoadBalancer) (ent.Value, error) {
			return lb.ID, nil
		},
		column: loadbalancer.FieldID,
		toTerm: loadbalancer.ByID,
		toCursor: func(lb *LoadBalancer) Cursor {
			return Cursor{ID: lb.ID}
		},
	},
}

// ToEdge converts LoadBalancer into LoadBalancerEdge.
func (lb *LoadBalancer) ToEdge(order *LoadBalancerOrder) *LoadBalancerEdge {
	if order == nil {
		order = DefaultLoadBalancerOrder
	}
	return &LoadBalancerEdge{
		Node:   lb,
		Cursor: order.Field.toCursor(lb),
	}
}

// LoadBalancerOrigin is the type alias for Origin.
type LoadBalancerOrigin = Origin

// LoadBalancerOriginEdge is the edge representation of LoadBalancerOrigin.
type LoadBalancerOriginEdge struct {
	Node   *LoadBalancerOrigin `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// LoadBalancerOriginConnection is the connection containing edges to LoadBalancerOrigin.
type LoadBalancerOriginConnection struct {
	Edges      []*LoadBalancerOriginEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *LoadBalancerOriginConnection) build(nodes []*LoadBalancerOrigin, pager *loadbalanceroriginPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LoadBalancerOrigin
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LoadBalancerOrigin {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LoadBalancerOrigin {
			return nodes[i]
		}
	}
	c.Edges = make([]*LoadBalancerOriginEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LoadBalancerOriginEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LoadBalancerOriginPaginateOption enables pagination customization.
type LoadBalancerOriginPaginateOption func(*loadbalanceroriginPager) error

// WithLoadBalancerOriginOrder configures pagination ordering.
func WithLoadBalancerOriginOrder(order *LoadBalancerOriginOrder) LoadBalancerOriginPaginateOption {
	if order == nil {
		order = DefaultLoadBalancerOriginOrder
	}
	o := *order
	return func(pager *loadbalanceroriginPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLoadBalancerOriginOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLoadBalancerOriginFilter configures pagination filter.
func WithLoadBalancerOriginFilter(filter func(*OriginQuery) (*OriginQuery, error)) LoadBalancerOriginPaginateOption {
	return func(pager *loadbalanceroriginPager) error {
		if filter == nil {
			return errors.New("OriginQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type loadbalanceroriginPager struct {
	reverse bool
	order   *LoadBalancerOriginOrder
	filter  func(*OriginQuery) (*OriginQuery, error)
}

func newLoadBalancerOriginPager(opts []LoadBalancerOriginPaginateOption, reverse bool) (*loadbalanceroriginPager, error) {
	pager := &loadbalanceroriginPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLoadBalancerOriginOrder
	}
	return pager, nil
}

func (p *loadbalanceroriginPager) applyFilter(query *OriginQuery) (*OriginQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *loadbalanceroriginPager) toCursor(o *LoadBalancerOrigin) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *loadbalanceroriginPager) applyCursors(query *OriginQuery, after, before *Cursor) (*OriginQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLoadBalancerOriginOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *loadbalanceroriginPager) applyOrder(query *OriginQuery) *OriginQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLoadBalancerOriginOrder.Field {
		query = query.Order(DefaultLoadBalancerOriginOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *loadbalanceroriginPager) orderExpr(query *OriginQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLoadBalancerOriginOrder.Field {
			b.Comma().Ident(DefaultLoadBalancerOriginOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LoadBalancerOrigin.
func (o *OriginQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LoadBalancerOriginPaginateOption,
) (*LoadBalancerOriginConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLoadBalancerOriginPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &LoadBalancerOriginConnection{Edges: []*LoadBalancerOriginEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = o.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OriginOrderFieldCreatedAt orders Origin by created_at.
	OriginOrderFieldCreatedAt = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.CreatedAt, nil
		},
		column: origin.FieldCreatedAt,
		toTerm: origin.ByCreatedAt,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.CreatedAt,
			}
		},
	}
	// OriginOrderFieldUpdatedAt orders Origin by updated_at.
	OriginOrderFieldUpdatedAt = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.UpdatedAt, nil
		},
		column: origin.FieldUpdatedAt,
		toTerm: origin.ByUpdatedAt,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.UpdatedAt,
			}
		},
	}
	// OriginOrderFieldName orders Origin by name.
	OriginOrderFieldName = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.Name, nil
		},
		column: origin.FieldName,
		toTerm: origin.ByName,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Name,
			}
		},
	}
	// OriginOrderFieldWeight orders Origin by weight.
	OriginOrderFieldWeight = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.Weight, nil
		},
		column: origin.FieldWeight,
		toTerm: origin.ByWeight,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Weight,
			}
		},
	}
	// OriginOrderFieldTarget orders Origin by target.
	OriginOrderFieldTarget = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.Target, nil
		},
		column: origin.FieldTarget,
		toTerm: origin.ByTarget,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Target,
			}
		},
	}
	// OriginOrderFieldPortNumber orders Origin by port_number.
	OriginOrderFieldPortNumber = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.PortNumber, nil
		},
		column: origin.FieldPortNumber,
		toTerm: origin.ByPortNumber,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.PortNumber,
			}
		},
	}
	// OriginOrderFieldActive orders Origin by active.
	OriginOrderFieldActive = &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.Active, nil
		},
		column: origin.FieldActive,
		toTerm: origin.ByActive,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Active,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LoadBalancerOriginOrderField) String() string {
	var str string
	switch f.column {
	case OriginOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case OriginOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case OriginOrderFieldName.column:
		str = "name"
	case OriginOrderFieldWeight.column:
		str = "weight"
	case OriginOrderFieldTarget.column:
		str = "target"
	case OriginOrderFieldPortNumber.column:
		str = "number"
	case OriginOrderFieldActive.column:
		str = "active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LoadBalancerOriginOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LoadBalancerOriginOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LoadBalancerOriginOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OriginOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *OriginOrderFieldUpdatedAt
	case "name":
		*f = *OriginOrderFieldName
	case "weight":
		*f = *OriginOrderFieldWeight
	case "target":
		*f = *OriginOrderFieldTarget
	case "number":
		*f = *OriginOrderFieldPortNumber
	case "active":
		*f = *OriginOrderFieldActive
	default:
		return fmt.Errorf("%s is not a valid LoadBalancerOriginOrderField", str)
	}
	return nil
}

// LoadBalancerOriginOrderField defines the ordering field of Origin.
type LoadBalancerOriginOrderField struct {
	// Value extracts the ordering value from the given Origin.
	Value    func(*LoadBalancerOrigin) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) origin.OrderOption
	toCursor func(*LoadBalancerOrigin) Cursor
}

// LoadBalancerOriginOrder defines the ordering of Origin.
type LoadBalancerOriginOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *LoadBalancerOriginOrderField `json:"field"`
}

// DefaultLoadBalancerOriginOrder is the default ordering of Origin.
var DefaultLoadBalancerOriginOrder = &LoadBalancerOriginOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LoadBalancerOriginOrderField{
		Value: func(o *LoadBalancerOrigin) (ent.Value, error) {
			return o.ID, nil
		},
		column: origin.FieldID,
		toTerm: origin.ByID,
		toCursor: func(o *LoadBalancerOrigin) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts LoadBalancerOrigin into LoadBalancerOriginEdge.
func (o *LoadBalancerOrigin) ToEdge(order *LoadBalancerOriginOrder) *LoadBalancerOriginEdge {
	if order == nil {
		order = DefaultLoadBalancerOriginOrder
	}
	return &LoadBalancerOriginEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// LoadBalancerPool is the type alias for Pool.
type LoadBalancerPool = Pool

// LoadBalancerPoolEdge is the edge representation of LoadBalancerPool.
type LoadBalancerPoolEdge struct {
	Node   *LoadBalancerPool `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// LoadBalancerPoolConnection is the connection containing edges to LoadBalancerPool.
type LoadBalancerPoolConnection struct {
	Edges      []*LoadBalancerPoolEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *LoadBalancerPoolConnection) build(nodes []*LoadBalancerPool, pager *loadbalancerpoolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LoadBalancerPool
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LoadBalancerPool {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LoadBalancerPool {
			return nodes[i]
		}
	}
	c.Edges = make([]*LoadBalancerPoolEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LoadBalancerPoolEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LoadBalancerPoolPaginateOption enables pagination customization.
type LoadBalancerPoolPaginateOption func(*loadbalancerpoolPager) error

// WithLoadBalancerPoolOrder configures pagination ordering.
func WithLoadBalancerPoolOrder(order *LoadBalancerPoolOrder) LoadBalancerPoolPaginateOption {
	if order == nil {
		order = DefaultLoadBalancerPoolOrder
	}
	o := *order
	return func(pager *loadbalancerpoolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLoadBalancerPoolOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLoadBalancerPoolFilter configures pagination filter.
func WithLoadBalancerPoolFilter(filter func(*PoolQuery) (*PoolQuery, error)) LoadBalancerPoolPaginateOption {
	return func(pager *loadbalancerpoolPager) error {
		if filter == nil {
			return errors.New("PoolQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type loadbalancerpoolPager struct {
	reverse bool
	order   *LoadBalancerPoolOrder
	filter  func(*PoolQuery) (*PoolQuery, error)
}

func newLoadBalancerPoolPager(opts []LoadBalancerPoolPaginateOption, reverse bool) (*loadbalancerpoolPager, error) {
	pager := &loadbalancerpoolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLoadBalancerPoolOrder
	}
	return pager, nil
}

func (p *loadbalancerpoolPager) applyFilter(query *PoolQuery) (*PoolQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *loadbalancerpoolPager) toCursor(po *LoadBalancerPool) Cursor {
	return p.order.Field.toCursor(po)
}

func (p *loadbalancerpoolPager) applyCursors(query *PoolQuery, after, before *Cursor) (*PoolQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLoadBalancerPoolOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *loadbalancerpoolPager) applyOrder(query *PoolQuery) *PoolQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLoadBalancerPoolOrder.Field {
		query = query.Order(DefaultLoadBalancerPoolOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *loadbalancerpoolPager) orderExpr(query *PoolQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLoadBalancerPoolOrder.Field {
			b.Comma().Ident(DefaultLoadBalancerPoolOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LoadBalancerPool.
func (po *PoolQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LoadBalancerPoolPaginateOption,
) (*LoadBalancerPoolConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLoadBalancerPoolPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if po, err = pager.applyFilter(po); err != nil {
		return nil, err
	}
	conn := &LoadBalancerPoolConnection{Edges: []*LoadBalancerPoolEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = po.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if po, err = pager.applyCursors(po, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		po.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := po.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	po = pager.applyOrder(po)
	nodes, err := po.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PoolOrderFieldCreatedAt orders Pool by created_at.
	PoolOrderFieldCreatedAt = &LoadBalancerPoolOrderField{
		Value: func(po *LoadBalancerPool) (ent.Value, error) {
			return po.CreatedAt, nil
		},
		column: pool.FieldCreatedAt,
		toTerm: pool.ByCreatedAt,
		toCursor: func(po *LoadBalancerPool) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.CreatedAt,
			}
		},
	}
	// PoolOrderFieldUpdatedAt orders Pool by updated_at.
	PoolOrderFieldUpdatedAt = &LoadBalancerPoolOrderField{
		Value: func(po *LoadBalancerPool) (ent.Value, error) {
			return po.UpdatedAt, nil
		},
		column: pool.FieldUpdatedAt,
		toTerm: pool.ByUpdatedAt,
		toCursor: func(po *LoadBalancerPool) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.UpdatedAt,
			}
		},
	}
	// PoolOrderFieldName orders Pool by name.
	PoolOrderFieldName = &LoadBalancerPoolOrderField{
		Value: func(po *LoadBalancerPool) (ent.Value, error) {
			return po.Name, nil
		},
		column: pool.FieldName,
		toTerm: pool.ByName,
		toCursor: func(po *LoadBalancerPool) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.Name,
			}
		},
	}
	// PoolOrderFieldProtocol orders Pool by protocol.
	PoolOrderFieldProtocol = &LoadBalancerPoolOrderField{
		Value: func(po *LoadBalancerPool) (ent.Value, error) {
			return po.Protocol, nil
		},
		column: pool.FieldProtocol,
		toTerm: pool.ByProtocol,
		toCursor: func(po *LoadBalancerPool) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.Protocol,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LoadBalancerPoolOrderField) String() string {
	var str string
	switch f.column {
	case PoolOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PoolOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PoolOrderFieldName.column:
		str = "name"
	case PoolOrderFieldProtocol.column:
		str = "protocol"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LoadBalancerPoolOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LoadBalancerPoolOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LoadBalancerPoolOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PoolOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PoolOrderFieldUpdatedAt
	case "name":
		*f = *PoolOrderFieldName
	case "protocol":
		*f = *PoolOrderFieldProtocol
	default:
		return fmt.Errorf("%s is not a valid LoadBalancerPoolOrderField", str)
	}
	return nil
}

// LoadBalancerPoolOrderField defines the ordering field of Pool.
type LoadBalancerPoolOrderField struct {
	// Value extracts the ordering value from the given Pool.
	Value    func(*LoadBalancerPool) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) pool.OrderOption
	toCursor func(*LoadBalancerPool) Cursor
}

// LoadBalancerPoolOrder defines the ordering of Pool.
type LoadBalancerPoolOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *LoadBalancerPoolOrderField `json:"field"`
}

// DefaultLoadBalancerPoolOrder is the default ordering of Pool.
var DefaultLoadBalancerPoolOrder = &LoadBalancerPoolOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LoadBalancerPoolOrderField{
		Value: func(po *LoadBalancerPool) (ent.Value, error) {
			return po.ID, nil
		},
		column: pool.FieldID,
		toTerm: pool.ByID,
		toCursor: func(po *LoadBalancerPool) Cursor {
			return Cursor{ID: po.ID}
		},
	},
}

// ToEdge converts LoadBalancerPool into LoadBalancerPoolEdge.
func (po *LoadBalancerPool) ToEdge(order *LoadBalancerPoolOrder) *LoadBalancerPoolEdge {
	if order == nil {
		order = DefaultLoadBalancerPoolOrder
	}
	return &LoadBalancerPoolEdge{
		Node:   po,
		Cursor: order.Field.toCursor(po),
	}
}

// LoadBalancerPort is the type alias for Port.
type LoadBalancerPort = Port

// LoadBalancerPortEdge is the edge representation of LoadBalancerPort.
type LoadBalancerPortEdge struct {
	Node   *LoadBalancerPort `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// LoadBalancerPortConnection is the connection containing edges to LoadBalancerPort.
type LoadBalancerPortConnection struct {
	Edges      []*LoadBalancerPortEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *LoadBalancerPortConnection) build(nodes []*LoadBalancerPort, pager *loadbalancerportPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LoadBalancerPort
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LoadBalancerPort {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LoadBalancerPort {
			return nodes[i]
		}
	}
	c.Edges = make([]*LoadBalancerPortEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LoadBalancerPortEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LoadBalancerPortPaginateOption enables pagination customization.
type LoadBalancerPortPaginateOption func(*loadbalancerportPager) error

// WithLoadBalancerPortOrder configures pagination ordering.
func WithLoadBalancerPortOrder(order *LoadBalancerPortOrder) LoadBalancerPortPaginateOption {
	if order == nil {
		order = DefaultLoadBalancerPortOrder
	}
	o := *order
	return func(pager *loadbalancerportPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLoadBalancerPortOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLoadBalancerPortFilter configures pagination filter.
func WithLoadBalancerPortFilter(filter func(*PortQuery) (*PortQuery, error)) LoadBalancerPortPaginateOption {
	return func(pager *loadbalancerportPager) error {
		if filter == nil {
			return errors.New("PortQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type loadbalancerportPager struct {
	reverse bool
	order   *LoadBalancerPortOrder
	filter  func(*PortQuery) (*PortQuery, error)
}

func newLoadBalancerPortPager(opts []LoadBalancerPortPaginateOption, reverse bool) (*loadbalancerportPager, error) {
	pager := &loadbalancerportPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLoadBalancerPortOrder
	}
	return pager, nil
}

func (p *loadbalancerportPager) applyFilter(query *PortQuery) (*PortQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *loadbalancerportPager) toCursor(po *LoadBalancerPort) Cursor {
	return p.order.Field.toCursor(po)
}

func (p *loadbalancerportPager) applyCursors(query *PortQuery, after, before *Cursor) (*PortQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLoadBalancerPortOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *loadbalancerportPager) applyOrder(query *PortQuery) *PortQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLoadBalancerPortOrder.Field {
		query = query.Order(DefaultLoadBalancerPortOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *loadbalancerportPager) orderExpr(query *PortQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLoadBalancerPortOrder.Field {
			b.Comma().Ident(DefaultLoadBalancerPortOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LoadBalancerPort.
func (po *PortQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LoadBalancerPortPaginateOption,
) (*LoadBalancerPortConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLoadBalancerPortPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if po, err = pager.applyFilter(po); err != nil {
		return nil, err
	}
	conn := &LoadBalancerPortConnection{Edges: []*LoadBalancerPortEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = po.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if po, err = pager.applyCursors(po, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		po.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := po.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	po = pager.applyOrder(po)
	nodes, err := po.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PortOrderFieldCreatedAt orders Port by created_at.
	PortOrderFieldCreatedAt = &LoadBalancerPortOrderField{
		Value: func(po *LoadBalancerPort) (ent.Value, error) {
			return po.CreatedAt, nil
		},
		column: port.FieldCreatedAt,
		toTerm: port.ByCreatedAt,
		toCursor: func(po *LoadBalancerPort) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.CreatedAt,
			}
		},
	}
	// PortOrderFieldUpdatedAt orders Port by updated_at.
	PortOrderFieldUpdatedAt = &LoadBalancerPortOrderField{
		Value: func(po *LoadBalancerPort) (ent.Value, error) {
			return po.UpdatedAt, nil
		},
		column: port.FieldUpdatedAt,
		toTerm: port.ByUpdatedAt,
		toCursor: func(po *LoadBalancerPort) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.UpdatedAt,
			}
		},
	}
	// PortOrderFieldNumber orders Port by number.
	PortOrderFieldNumber = &LoadBalancerPortOrderField{
		Value: func(po *LoadBalancerPort) (ent.Value, error) {
			return po.Number, nil
		},
		column: port.FieldNumber,
		toTerm: port.ByNumber,
		toCursor: func(po *LoadBalancerPort) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.Number,
			}
		},
	}
	// PortOrderFieldName orders Port by name.
	PortOrderFieldName = &LoadBalancerPortOrderField{
		Value: func(po *LoadBalancerPort) (ent.Value, error) {
			return po.Name, nil
		},
		column: port.FieldName,
		toTerm: port.ByName,
		toCursor: func(po *LoadBalancerPort) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LoadBalancerPortOrderField) String() string {
	var str string
	switch f.column {
	case PortOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PortOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PortOrderFieldNumber.column:
		str = "number"
	case PortOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LoadBalancerPortOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LoadBalancerPortOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LoadBalancerPortOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PortOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PortOrderFieldUpdatedAt
	case "number":
		*f = *PortOrderFieldNumber
	case "name":
		*f = *PortOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid LoadBalancerPortOrderField", str)
	}
	return nil
}

// LoadBalancerPortOrderField defines the ordering field of Port.
type LoadBalancerPortOrderField struct {
	// Value extracts the ordering value from the given Port.
	Value    func(*LoadBalancerPort) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) port.OrderOption
	toCursor func(*LoadBalancerPort) Cursor
}

// LoadBalancerPortOrder defines the ordering of Port.
type LoadBalancerPortOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *LoadBalancerPortOrderField `json:"field"`
}

// DefaultLoadBalancerPortOrder is the default ordering of Port.
var DefaultLoadBalancerPortOrder = &LoadBalancerPortOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LoadBalancerPortOrderField{
		Value: func(po *LoadBalancerPort) (ent.Value, error) {
			return po.ID, nil
		},
		column: port.FieldID,
		toTerm: port.ByID,
		toCursor: func(po *LoadBalancerPort) Cursor {
			return Cursor{ID: po.ID}
		},
	},
}

// ToEdge converts LoadBalancerPort into LoadBalancerPortEdge.
func (po *LoadBalancerPort) ToEdge(order *LoadBalancerPortOrder) *LoadBalancerPortEdge {
	if order == nil {
		order = DefaultLoadBalancerPortOrder
	}
	return &LoadBalancerPortEdge{
		Node:   po,
		Cursor: order.Field.toCursor(po),
	}
}

// LoadBalancerProvider is the type alias for Provider.
type LoadBalancerProvider = Provider

// LoadBalancerProviderEdge is the edge representation of LoadBalancerProvider.
type LoadBalancerProviderEdge struct {
	Node   *LoadBalancerProvider `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// LoadBalancerProviderConnection is the connection containing edges to LoadBalancerProvider.
type LoadBalancerProviderConnection struct {
	Edges      []*LoadBalancerProviderEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *LoadBalancerProviderConnection) build(nodes []*LoadBalancerProvider, pager *loadbalancerproviderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LoadBalancerProvider
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LoadBalancerProvider {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LoadBalancerProvider {
			return nodes[i]
		}
	}
	c.Edges = make([]*LoadBalancerProviderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LoadBalancerProviderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LoadBalancerProviderPaginateOption enables pagination customization.
type LoadBalancerProviderPaginateOption func(*loadbalancerproviderPager) error

// WithLoadBalancerProviderOrder configures pagination ordering.
func WithLoadBalancerProviderOrder(order *LoadBalancerProviderOrder) LoadBalancerProviderPaginateOption {
	if order == nil {
		order = DefaultLoadBalancerProviderOrder
	}
	o := *order
	return func(pager *loadbalancerproviderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLoadBalancerProviderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLoadBalancerProviderFilter configures pagination filter.
func WithLoadBalancerProviderFilter(filter func(*ProviderQuery) (*ProviderQuery, error)) LoadBalancerProviderPaginateOption {
	return func(pager *loadbalancerproviderPager) error {
		if filter == nil {
			return errors.New("ProviderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type loadbalancerproviderPager struct {
	reverse bool
	order   *LoadBalancerProviderOrder
	filter  func(*ProviderQuery) (*ProviderQuery, error)
}

func newLoadBalancerProviderPager(opts []LoadBalancerProviderPaginateOption, reverse bool) (*loadbalancerproviderPager, error) {
	pager := &loadbalancerproviderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLoadBalancerProviderOrder
	}
	return pager, nil
}

func (p *loadbalancerproviderPager) applyFilter(query *ProviderQuery) (*ProviderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *loadbalancerproviderPager) toCursor(pr *LoadBalancerProvider) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *loadbalancerproviderPager) applyCursors(query *ProviderQuery, after, before *Cursor) (*ProviderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLoadBalancerProviderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *loadbalancerproviderPager) applyOrder(query *ProviderQuery) *ProviderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLoadBalancerProviderOrder.Field {
		query = query.Order(DefaultLoadBalancerProviderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *loadbalancerproviderPager) orderExpr(query *ProviderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLoadBalancerProviderOrder.Field {
			b.Comma().Ident(DefaultLoadBalancerProviderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LoadBalancerProvider.
func (pr *ProviderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LoadBalancerProviderPaginateOption,
) (*LoadBalancerProviderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLoadBalancerProviderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &LoadBalancerProviderConnection{Edges: []*LoadBalancerProviderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProviderOrderFieldID orders Provider by id.
	ProviderOrderFieldID = &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.ID, nil
		},
		column: provider.FieldID,
		toTerm: provider.ByID,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.ID,
			}
		},
	}
	// ProviderOrderFieldCreatedAt orders Provider by created_at.
	ProviderOrderFieldCreatedAt = &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: provider.FieldCreatedAt,
		toTerm: provider.ByCreatedAt,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProviderOrderFieldUpdatedAt orders Provider by updated_at.
	ProviderOrderFieldUpdatedAt = &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: provider.FieldUpdatedAt,
		toTerm: provider.ByUpdatedAt,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProviderOrderFieldName orders Provider by name.
	ProviderOrderFieldName = &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.Name, nil
		},
		column: provider.FieldName,
		toTerm: provider.ByName,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProviderOrderFieldOwnerID orders Provider by owner_id.
	ProviderOrderFieldOwnerID = &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.OwnerID, nil
		},
		column: provider.FieldOwnerID,
		toTerm: provider.ByOwnerID,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.OwnerID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LoadBalancerProviderOrderField) String() string {
	var str string
	switch f.column {
	case ProviderOrderFieldID.column:
		str = "ID"
	case ProviderOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProviderOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProviderOrderFieldName.column:
		str = "NAME"
	case ProviderOrderFieldOwnerID.column:
		str = "OWNER"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LoadBalancerProviderOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LoadBalancerProviderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LoadBalancerProviderOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *ProviderOrderFieldID
	case "CREATED_AT":
		*f = *ProviderOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProviderOrderFieldUpdatedAt
	case "NAME":
		*f = *ProviderOrderFieldName
	case "OWNER":
		*f = *ProviderOrderFieldOwnerID
	default:
		return fmt.Errorf("%s is not a valid LoadBalancerProviderOrderField", str)
	}
	return nil
}

// LoadBalancerProviderOrderField defines the ordering field of Provider.
type LoadBalancerProviderOrderField struct {
	// Value extracts the ordering value from the given Provider.
	Value    func(*LoadBalancerProvider) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) provider.OrderOption
	toCursor func(*LoadBalancerProvider) Cursor
}

// LoadBalancerProviderOrder defines the ordering of Provider.
type LoadBalancerProviderOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *LoadBalancerProviderOrderField `json:"field"`
}

// DefaultLoadBalancerProviderOrder is the default ordering of Provider.
var DefaultLoadBalancerProviderOrder = &LoadBalancerProviderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LoadBalancerProviderOrderField{
		Value: func(pr *LoadBalancerProvider) (ent.Value, error) {
			return pr.ID, nil
		},
		column: provider.FieldID,
		toTerm: provider.ByID,
		toCursor: func(pr *LoadBalancerProvider) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts LoadBalancerProvider into LoadBalancerProviderEdge.
func (pr *LoadBalancerProvider) ToEdge(order *LoadBalancerProviderOrder) *LoadBalancerProviderEdge {
	if order == nil {
		order = DefaultLoadBalancerProviderOrder
	}
	return &LoadBalancerProviderEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}
